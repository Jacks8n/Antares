#pragma kernel AddParticles

#include "HLSLSupport.cginc"
#include "FluidData.cginc"
#include "../Shaders/Random.cginc"

/// begin add particle

#define ADD_PARTICLES_KERNEL_SIZE 128
#define MAX_EMITTER_PARTICLE_COUNT_PER_GROUP (ADD_PARTICLES_KERNEL_SIZE * 8)

#define EMITTER_TYPE_PARTICLE 0
#define EMITTER_TYPE_CUBE 1

CBUFFER_START(AddParticlesParameters)
uint FluidEmitterCount;

float Mass;

uint RandomSeed;
CBUFFER_END

struct FluidEmitter
{
    uint Type;

    // in bytes
    uint ParameterOffset;

    uint ParticleCountInclusiveSum;
};

extern ByteAddressBuffer FluidEmitters;
extern Buffer<uint> FluidEmitterPartitions;

// layout: { <valid emitter paramter layout>* }
// particle emitter: { position, velocity }
// cube emitter: { min pos, max pos }
extern ByteAddressBuffer FluidEmitterParameters;

FluidEmitter GetFluidEmitter(uint index)
{
    const uint size = sizeof(FluidEmitter);
    const uint3 word = FluidEmitters.Load3(index * size);

    FluidEmitter emitter;
    emitter.Type = word.x;
    emitter.ParameterOffset = word.y;
    emitter.ParticleCountInclusiveSum = word.z;

    float foo[] = (float[sizeof(emitter) / 4])emitter;
    emitter = (FluidEmitter)foo;

    return emitter;
}

void GetEmittedParticle(
    uint emitterType, uint emitterParameterOffset, uint emitterParticleIndex,
    inout Random random, out float3 position, out float3 velocity, out float mass)
{
    switch (emitterType)
    {
    case EMITTER_TYPE_PARTICLE:
    {
        const uint offset = emitterParameterOffset + emitterParticleIndex * 24;
        const float4 word0 = asfloat(FluidEmitterParameters.Load4(offset));
        const float2 word1 = asfloat(FluidEmitterParameters.Load2(offset + 16));

        position = word0.xyz;
        velocity = float3(word0.w, word1);
    }
    break;
    case EMITTER_TYPE_CUBE:
    {
        const uint offset = emitterParameterOffset;
        const float4 word0 = asfloat(FluidEmitterParameters.Load4(offset));
        const float4 word1 = asfloat(FluidEmitterParameters.Load4(offset + 16));
        const float4 word2 = asfloat(FluidEmitterParameters.Load4(offset + 32));

        const float3 cubeMin = float3(word0.xyz);
        const float3 cubeMax = float3(word0.w, word1.xy);
        const float3 uvw = random.Next01x3();
        position = lerp(cubeMin, cubeMax, uvw);

        const float3 cubeCenter = (cubeMax + cubeMin) * 0.5;
        const float3 angularVelocity = float3(word2.yzw);
        velocity = cross(angularVelocity, position - cubeCenter);

        const float3 linearVelocity = float3(word1.zw, word2.x);
        velocity += linearVelocity;
    }
    break;
    default:
    {
        // random negative value for debugging
        position = float(-42.0).xxx;
        velocity = float(-42.0).xxx;
    }
    break;
    }

    mass = Mass;
}

groupshared uint EmitterOffset_GSM;
groupshared uint EmitterCount_GSM;
groupshared uint EmitterParticleOffset_GSM;
groupshared uint EmitterTypes_GSM[MAX_EMITTER_PARTICLE_COUNT_PER_GROUP];
groupshared uint EmitterParameterOffsets_GSM[MAX_EMITTER_PARTICLE_COUNT_PER_GROUP];
groupshared uint EmitterIndices_GSM[MAX_EMITTER_PARTICLE_COUNT_PER_GROUP + 1];
groupshared uint TotalEmitterParticleCount_GSM;

[numthreads(ADD_PARTICLES_KERNEL_SIZE, 1, 1)]
void AddParticles(uint3 tid : SV_DispatchThreadID, uint3 gid : SV_GroupID, uint gi : SV_GroupIndex)
{
    uint i, j;

    // clear emitter indices
    for (i = gi; i < MAX_EMITTER_PARTICLE_COUNT_PER_GROUP; i += ADD_PARTICLES_KERNEL_SIZE)
    {
        EmitterIndices_GSM[i] = ~0u;
    }

    if (!gi)
    {
        EmitterOffset_GSM = FluidEmitterPartitions[gid.x];
        EmitterCount_GSM = FluidEmitterPartitions[gid.x + 1] - EmitterOffset_GSM;
        EmitterParticleOffset_GSM = gid.x * PARTICLE_TO_GRID_KERNEL_SIZE;
    }

    GroupMemoryBarrierWithGroupSync();

    // load emitters to gsm
    for (i = gi; i < EmitterCount_GSM; i += ADD_PARTICLES_KERNEL_SIZE)
    {
        const FluidEmitter emitter = GetFluidEmitter(i + EmitterOffset_GSM);
        EmitterTypes_GSM[i] = emitter.Type;
        EmitterParameterOffsets_GSM[i] = emitter.ParameterOffset;
        EmitterIndices_GSM[emitter.ParticleCountInclusiveSum] = i + 1;

        if (i == EmitterCount_GSM - 1)
            TotalEmitterParticleCount_GSM = emitter.ParticleCountInclusiveSum;
    }

    GroupMemoryBarrierWithGroupSync();

    // broadcast emitters
    for (i = 1; i < TotalEmitterParticleCount_GSM; i *= 2)
    {
        for (j = gi; j + i < TotalEmitterParticleCount_GSM; j += ADD_PARTICLES_KERNEL_SIZE)
        {
            const uint current = EmitterIndices_GSM[j];
            if (current != ~0)
            {
                const uint nextIndex = j + i;
                const uint next = EmitterIndices_GSM[nextIndex];
                if (next == ~0)
                    EmitterIndices_GSM[nextIndex] = current;
            }
        }

        GroupMemoryBarrierWithGroupSync();
    }

    const bool pingpongFlag = GetFluidParticlePositionPingPongFlag();
    const uint poolSize = GetPooledParticlePropertyCount();
    const uint prevParticleCount = GetFluidParticleCount();

    Random random;
    random.Seed(RandomSeed, tid.x);

    for (i = gi; i < TotalEmitterParticleCount_GSM; i += ADD_PARTICLES_KERNEL_SIZE)
    {
        const uint emitterIndex = EmitterIndices_GSM[i];
        const uint emitterType = EmitterTypes_GSM[emitterIndex];
        const uint emitterParameterOffset = EmitterParameterOffsets_GSM[emitterIndex];

        float3 position;
        float3 velocity;
        float mass;
        GetEmittedParticle(emitterType, emitterParameterOffset, i, random, position, velocity, mass);

        const uint particleIndex = EmitterParticleOffset_GSM + i;

        uint propertyIndex;
        if (particleIndex < poolSize)
            propertyIndex = GetPooledParticleProperty(poolSize - 1 - particleIndex);
        else
            propertyIndex = prevParticleCount + particleIndex;

        ParticlePositionIndexed positionIndexed;
        positionIndexed.Position = position;
        positionIndexed.Index = propertyIndex;

        ParticleProperties properties;
        properties.SetVelocity(velocity);
        properties.SetZeroAffine();
        properties.Mass = mass;

        SetFluidParticlePosition(prevParticleCount + particleIndex, positionIndexed, pingpongFlag);
        SetFluidParticleProperties(propertyIndex, properties);
    }
}

/// end add particle
