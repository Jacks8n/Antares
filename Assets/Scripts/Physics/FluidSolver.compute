// here a hybrid eulerian-lagrangian scheme is implemented, specifically a tailored mls-mpm [Hu et al. 2018].
// refer to the links below for detail:
//  - original mls-mpm paper: https://www.yzhu.io/projects/siggraph18_mlsmpm_cpic/index.html
//  - implementation examples: https://nialltl.neocities.org/articles/mpm_guide.html
//
// as for the sparse data structure, there are various choices, e.g., octree, vdb, spgrid.
// after some comparisons, i used something similar to the gspgrid as the sparse data structure.
// some references are available:
//  - original spgrid paper: https://pages.cs.wisc.edu/~sifakis/project_pages/SPGrid.html
//  - gpu optimization of mpm: https://doi.org/10.1145/3272127.3275044
//      - where gspgrid and some inspirng optimization are introduced
//  - taichi programming language: https://doi.org/10.1145/3355089.3356506
//      - special thanks to their benchmarks!
//  - original vdb paper: http://dx.doi.org/10.1145/2487228.2487235
//  - nanovdb implementation: https://github.com/AcademySoftwareFoundation/openvdb/blob/feature/nanovdb/nanovdb/nanovdb/nanovdb/NanoVDB.h

#pragma use_dxc
#pragma enable_d3d11_debug_symbols

#pragma kernel SortParticle
#pragma kernel ParticleToGrid
#pragma kernel SolveGrid
#pragma kernel GridToParticle
#pragma kernel GenerateIndirectArgs
#pragma kernel AddParticles

#include "HLSLSupport.cginc"
#include "FluidData.cginc"

/// begin constant buffer

CBUFFER_START(PhysicsSceneParameters)
    float2 FluidGridResolution;
    #define FLUID_GRID_RESOLUTION FluidGridResolution.x
    #define FLUID_GRID_RESOLUTION_INV FluidGridResolution.y

    float MassGridToSDFThreshold;
CBUFFER_END

CBUFFER_START(PhysicsFrameParameters)
    // when the time step is 0, inverse of it should be 0 too
    float2 TimeStep;
    #define TIME_STEP TimeStep.x
    #define TIME_STEP_INV TimeStep.y

    float2 Padding1;

    float3 FluidGravity;
    #define GLOBAL_GRAVITY FluidGravity

    float Padding2;

    float3 FluidGridTranslation;
CBUFFER_END

/// end constant buffer

/// begin sort particle

#define SORT_PARTICLE_KERNEL_SIZE 128

float3 Square(float3 x)
{
    return x * x;
}

float Pow4(float x)
{
    x *= x;
    x *= x;
    return x;
}

float3 GetGridSpacePosition(float3 worldSpacePosition)
{
    return (worldSpacePosition - FluidGridTranslation) * FLUID_GRID_RESOLUTION_INV;
}

[numthreads(SORT_PARTICLE_KERNEL_SIZE, 1, 1)]
void SortParticle(uint3 id : SV_DispatchThreadID)
{
    const uint particleCount = GetFluidParticleCount();
    const bool pingpongFlag = GetFluidParticlePositionPingPongFlag();

    uint i;
    for (i = id.x; i < particleCount; i += SORT_PARTICLE_KERNEL_SIZE)
    {
        const ParticlePositionIndexed position = GetFluidParticlePosition(i, pingpongFlag);

        const int3 gridPosition = GetFluidGridPosition(GetGridSpacePosition(position.Position));
        AddParticleToFluidBlock(gridPosition, i);
    }
}

/// end sort particle

/// begin particle to grid

#define PARTICLE_TO_GRID_KERNEL_SIZE 128
#define FLUID_BLOCK_PADDING 2
#define FLUID_BLOCK_SIZE_LEVEL0_PADDED (FLUID_BLOCK_SIZE_LEVEL0 + FLUID_BLOCK_PADDING)
#define FLUID_BLOCK_GRID_COUNT_LEVEL0_PADDED (FLUID_BLOCK_SIZE_LEVEL0_PADDED * FLUID_BLOCK_SIZE_LEVEL0_PADDED * FLUID_BLOCK_SIZE_LEVEL0_PADDED)

struct ParticleGSM
{
    float Mass;

    float3 AffineRow0;

    float PositionX;

    float3 AffineRow1;

    float PositionY;

    float3 AffineRow2;

    float PositionZ;
    
    float3 GetPosition()
    {
        return float3(PositionX, PositionY, PositionZ);
    }

    void SetPosition(float3 position)
    {
        PositionX = position.x;
        PositionY = position.y;
        PositionZ = position.z;
    }

    float3x3 GetAffine()
    {
        return float3x3(AffineRow0, AffineRow1, AffineRow2);
    }

    void SetAffine(float3x3 affine)
    {
        AffineRow0 = affine._m00_m01_m02;
        AffineRow1 = affine._m10_m11_m12;
        AffineRow2 = affine._m20_m21_m22;
    }
};

void CalculateWeights(float3 gridToParticle, out float3 weight0, out float3 weight1, out float3 weight2)
{
    weight0 = 0.5 * Square(1.5 - gridToParticle);
    weight1 = 0.75 - Square(gridToParticle - 1.0);
    weight2 = 0.5 * Square(gridToParticle - 0.5);
}

void CalculateParticleGridTransfer(
    float3 particlePosition, uint3 blockPositionLevel1, out float3 blockSpacePos, out uint3 gridIndex,
    out float3 gridToParticle, out float3 weight0, out float3 weight1, out float3 weight2)
{
    blockSpacePos = GetGridSpacePosition(particlePosition) - blockPositionLevel1 * FLUID_BLOCK_SIZE_LEVEL0;
    gridIndex = uint3(blockSpacePos - float(0.5).xxx);
    gridToParticle = blockSpacePos - gridIndex;

    CalculateWeights(gridToParticle, weight0, weight1, weight2);
}

void WaveGetMaxInterval(bool flag, out uint interval, out uint maxInterval)
{
    const uint laneIndex = WaveGetLaneIndex();
    const uint laneCount = WaveGetLaneCount();

    interval = 1;
    uint stride = 1;
    while (stride < laneCount)
    {
        const uint dstLane = laneIndex + stride;
        const bool dstFlag = WaveReadLaneAt(flag, dstLane);

        if (dstLane < laneCount && !dstFlag)
            interval += WaveReadLaneAt(interval, dstLane);

        stride *= 2;
    }

    maxInterval = WaveActiveMax(flag ? interval : 0);
}

groupshared uint SortParticleOffset_GSM;
// size: 16 * 216 = 3456 bytes
groupshared int4 FluidGrid_GSM[FLUID_BLOCK_GRID_COUNT_LEVEL0_PADDED];
// size: 16 * 216 = 3456 bytes
groupshared float4 FluidGridDecoded_GSM[FLUID_BLOCK_GRID_COUNT_LEVEL0_PADDED];
// size: 52 * 60 = 3120 bytes
groupshared ParticleGSM Particles_GSM[FLUID_BLOCK_MAX_PARTICLE_COUNT];

[numthreads(PARTICLE_TO_GRID_KERNEL_SIZE, 1, 1)]
void ParticleToGrid(uint3 gid : SV_GroupID, uint gi : SV_GroupIndex)
{
    uint i, j, k, l;

    // initialize grid gsm
    for (i = gi; i < FLUID_BLOCK_GRID_COUNT_LEVEL0_PADDED; i += PARTICLE_TO_GRID_KERNEL_SIZE)
    {
        FluidGrid_GSM[i] = 0;
    }

    uint3 blockPositionLevel1;
    uint particleCount;
    GetFluidBlockInfo(gid.x, blockPositionLevel1, particleCount);

    if (!gi)
        SortParticleOffset_GSM = AddParticleCountAtomic(particleCount);

    GroupMemoryBarrierWithGroupSync();

    const bool pingpongFlag = GetFluidParticlePositionPingPongFlag();

    // per particle scatter
    for (i = gi; i < particleCount; i += PARTICLE_TO_GRID_KERNEL_SIZE)
    {
        // read particle from arrays attached to block
        const uint particleIndex = GetFluidBlockParticleIndex(gid.x, i);
        const ParticlePositionIndexed position = GetFluidParticlePosition(particleIndex, pingpongFlag);
        const ParticleProperties properties = GetFluidParticleProperties(position.Index);

        const float3 velocity = properties.GetVelocity();
        const float3x3 affine = properties.GetAffine();

        // cache particle
        Particles_GSM[i].Mass = properties.Mass;
        Particles_GSM[i].SetPosition(position.Position);
        Particles_GSM[i].SetAffine(affine);

        // calculate indices and weights
        float3 blockSpacePos;
        uint3 gridIndex;
        float3 gridToParticle;
        float3 weights[3];
        CalculateParticleGridTransfer(
            position.Position, blockPositionLevel1, blockSpacePos, gridIndex, gridToParticle,
            weights[0], weights[1], weights[2]);

        const uint gridIndexEncoded = EncodeFluidGridIndexLevel0(gridIndex, FLUID_BLOCK_PADDING);

        // preparation to handle inter-wave conflicts
        const uint laneIndex = WaveGetLaneIndex();
        const bool isLo = gridIndexEncoded != WaveReadLaneAt(gridIndexEncoded, min(0, laneIndex - 1)) || !laneIndex;
        
        uint interval, intervalMax;
        WaveGetMaxInterval(isLo, interval, intervalMax);

        // simplified mls-mpm p2g
        for (j = 0; j < 3; j++)
        {
            for (k = 0; k < 3; k++)
            {
                for (l = 0; l < 3; l++)
                {
                    const float weight = weights[j].x * weights[k].y * weights[l].z;

                    const float3 affineVelocity = mul(affine, float3(j, k, l) - gridToParticle);

                    float4 massMomentum;
                    massMomentum.x = weight * properties.Mass;
                    massMomentum.yzw = massMomentum.x * (velocity + affineVelocity);

                    uint stride = 1;
                    while (stride < intervalMax)
                    {
                        const uint dstLane = laneIndex + stride;
                        const float4 temp = WaveReadLaneAt(massMomentum, dstLane);

                        if (stride < interval)
                            massMomentum += temp;

                        stride *= 2;
                    }

                    if (isLo)
                    {
                        const uint dstGridIndexEncoded = gridIndexEncoded + EncodeFluidGridIndexLevel0(uint3(j, k, l), FLUID_BLOCK_PADDING);
                        const int massEncoded = EncodeFluidGridMass(massMomentum.x);
                        const int3 momentumEncoded = EncodeFluidGridMomentum(massMomentum.yzw);

                        // currently 4-element atomic add is unspported
                        int _;
                        InterlockedAdd(FluidGrid_GSM[dstGridIndexEncoded].x, massEncoded, _);
                        InterlockedAdd(FluidGrid_GSM[dstGridIndexEncoded].y, momentumEncoded.x, _);
                        InterlockedAdd(FluidGrid_GSM[dstGridIndexEncoded].z, momentumEncoded.y, _);
                        InterlockedAdd(FluidGrid_GSM[dstGridIndexEncoded].w, momentumEncoded.z, _);
                    }
                }
            }
        }

        // sort particle
        SetFluidParticlePosition(SortParticleOffset_GSM + i, position, !pingpongFlag);
    }

    GroupMemoryBarrierWithGroupSync();

    // convert to float
    for (i = gi; i < FLUID_BLOCK_GRID_COUNT_LEVEL0_PADDED; i += PARTICLE_TO_GRID_KERNEL_SIZE)
    {
        FluidGridDecoded_GSM[i] = float4(
            DecodeFluidGridMass(FluidGrid_GSM[i].x),
            DecodeFluidGridMomentum(FluidGrid_GSM[i].yzw));
    }

    GroupMemoryBarrierWithGroupSync();

    // density, pressure, stress etc.
    for (i = gi; i < particleCount; i += PARTICLE_TO_GRID_KERNEL_SIZE)
    {
        const ParticleGSM particle = Particles_GSM[i];

        // calculate indices and weights
        float3 blockSpacePos;
        uint3 gridIndexOffset;
        float3 gridToParticle;
        float3 weights[3];
        CalculateParticleGridTransfer(
            particle.GetPosition(), blockPositionLevel1, blockSpacePos, gridIndexOffset, gridToParticle,
            weights[0], weights[1], weights[2]);

        const uint gridIndexOffsetEncoded = EncodeFluidGridIndexLevel0(gridIndexOffset, FLUID_BLOCK_PADDING);

        float density = 0.0;
        for (j = 0; j < 3; j++)
        {
            for (k = 0; k < 3; k++)
            {
                for (l = 0; l < 3; l++)
                {
                    const float weight = weights[j].x * weights[k].y * weights[l].z;
                    const uint gridIndexEncoded = gridIndexOffsetEncoded + EncodeFluidGridIndexLevel0(uint3(j, k, l), FLUID_BLOCK_PADDING);

                    density += weight * FluidGridDecoded_GSM[gridIndexEncoded].x;
                }
            }
        }

        // tait-murnaghan equation of state
        const float pressure = (FLUID_EOS_BULK_MODULUS * 0.25) * Pow4(density * (1.0 / FLUID_EOS_REST_DENSITY));
        const float volume = particle.Mass / density;
        const float3x3 affine = particle.GetAffine();

        float3x3 stress = FLUID_VISCOSITY_COEFFICIENT * (affine + transpose(affine));
        stress._m00 -= pressure;
        stress._m11 -= pressure;
        stress._m22 -= pressure;

        const float3x3 c = 3.0 * TIME_STEP * volume * stress;

        // preparation to handle inter-wave conflicts
        const uint laneIndex = WaveGetLaneIndex();
        const uint prevLane = min(0, laneIndex - 1);
        const bool isLo = gridIndexOffset != WaveReadLaneAt(gridIndexOffset, prevLane) || !laneIndex;

        uint interval, intervalMax;
        WaveGetMaxInterval(isLo, interval, intervalMax);

        for (j = 0; j < 3; j++)
        {
            for (k = 0; k < 3; k++)
            {
                for (l = 0; l < 3; l++)
                {
                    const float weight = weights[j].x * weights[k].y * weights[l].z;

                    float3 momentum = weight * mul(c, gridToParticle - float3(j, k, l));

                    uint stride = 1;
                    while (stride < intervalMax)
                    {
                        const uint dstLane = laneIndex + stride;
                        const float3 temp = WaveReadLaneAt(momentum, dstLane);

                        if (stride < interval)
                            momentum += temp;

                        stride *= 2;
                    }

                    if (isLo)
                    {
                        const uint dstGridIndexEncoded = gridIndexOffsetEncoded + EncodeFluidGridIndexLevel0(uint3(j, k, l), FLUID_BLOCK_PADDING);
                        const int3 momentumEncoded = EncodeFluidGridMomentum(momentum);

                        int _;
                        InterlockedAdd(FluidGrid_GSM[dstGridIndexEncoded].y, momentumEncoded.x, _);
                        InterlockedAdd(FluidGrid_GSM[dstGridIndexEncoded].z, momentumEncoded.y, _);
                        InterlockedAdd(FluidGrid_GSM[dstGridIndexEncoded].w, momentumEncoded.z, _);
                    }
                }
            }
        }
    }

    GroupMemoryBarrierWithGroupSync();

    // write to global uav
    for (i = gi; i < FLUID_BLOCK_GRID_COUNT_LEVEL0_PADDED; i += PARTICLE_TO_GRID_KERNEL_SIZE)
    {
        const uint3 srcGridIndex = DecodeFluidGridIndexLevel0(i, FLUID_BLOCK_PADDING);

        const uint3 blockOffset = uint3(srcGridIndex > FLUID_BLOCK_SIZE_LEVEL0);
        const uint blockIndexLevel0Encoded = GetFluidBlockIndexLevel0(blockPositionLevel1 + blockOffset);
        const uint3 blockIndex = DecodeFluidBlockIndexLevel0(blockIndexLevel0Encoded);

        const uint3 gridIndexOffset = blockIndex * FLUID_BLOCK_SIZE_LEVEL0;
        const uint3 dstGridIndex = srcGridIndex % FLUID_BLOCK_SIZE_LEVEL0 + gridIndexOffset;

        const int4 gridValue = FluidGrid_GSM[i];

        int _;
        InterlockedAdd(FluidGridLevel0[dstGridIndex + FLUID_GRID_CHANNEL0_OFFSET], gridValue.x, _);
        InterlockedAdd(FluidGridLevel0[dstGridIndex + FLUID_GRID_CHANNEL1_OFFSET], gridValue.y, _);
        InterlockedAdd(FluidGridLevel0[dstGridIndex + FLUID_GRID_CHANNEL2_OFFSET], gridValue.z, _);
        InterlockedAdd(FluidGridLevel0[dstGridIndex + FLUID_GRID_CHANNEL3_OFFSET], gridValue.w, _);
    }

    if (!gi)
        SetFluidBlockParticleCountPrefixSum(gi.x, SortParticleOffset_GSM);
}

/// end particle to grid

/// begin solve grid

#define SOLVE_GRID_KERNEL_SIZE 8

[numthreads(SOLVE_GRID_KERNEL_SIZE, SOLVE_GRID_KERNEL_SIZE, SOLVE_GRID_KERNEL_SIZE)]
void SolveGrid(uint3 gid : SV_GroupID, uint3 gtid : SV_GroupThreadID)
{
    const uint3 blockIndex = DecodeFluidBlockIndexLevel0(gid.x);
    const uint3 gridIndex = blockIndex * FLUID_BLOCK_SIZE_LEVEL0 + gtid;

    const int massEncoded = FluidGridLevel0[gridIndex + FLUID_GRID_CHANNEL0_OFFSET];
    const int3 momentumEncoded = int3(
        FluidGridLevel0[gridIndex + FLUID_GRID_CHANNEL1_OFFSET],
        FluidGridLevel0[gridIndex + FLUID_GRID_CHANNEL2_OFFSET],
        FluidGridLevel0[gridIndex + FLUID_GRID_CHANNEL3_OFFSET]);

    const float mass = DecodeFluidGridMass(massEncoded);
    const float3 momentum = DecodeFluidGridMomentum(momentumEncoded);

    const float3 velocity = momentum / mass + TIME_STEP * GLOBAL_GRAVITY;
    const int3 velocityEncoded = EncodeFluidGridMomentum(velocity);

    // todo
    // apply boundary condition here

    FluidGridLevel0[gridIndex + FLUID_GRID_CHANNEL1_OFFSET] = velocityEncoded.x;
    FluidGridLevel0[gridIndex + FLUID_GRID_CHANNEL2_OFFSET] = velocityEncoded.y;
    FluidGridLevel0[gridIndex + FLUID_GRID_CHANNEL3_OFFSET] = velocityEncoded.z;
}

/// end solve grid

/// begin grid to particle

#define GRID_TO_PARTICLE_KERNEL_SIZE 128

groupshared float3 GridVelocity_GSM[FLUID_BLOCK_GRID_COUNT_LEVEL0_PADDED];

[numthreads(GRID_TO_PARTICLE_KERNEL_SIZE, 1, 1)]
void GridToParticle(uint3 gid : SV_GroupID, uint gi : SV_GroupIndex)
{
    uint3 blockPositionLevel1;
    uint particleCount;
    uint particleOffset;
    GetFluidBlockInfo(gid.x, blockPositionLevel1, particleCount, particleOffset);

    uint i, j, k, l;

    for (i = gi; i < FLUID_BLOCK_GRID_COUNT_LEVEL0_PADDED; i += PARTICLE_TO_GRID_KERNEL_SIZE)
    {
        const uint3 srcGridIndex = DecodeFluidGridIndexLevel0(i, FLUID_BLOCK_PADDING);

        const uint3 blockOffset = uint3(srcGridIndex > FLUID_BLOCK_SIZE_LEVEL0);
        const uint blockIndexLevel0Encoded = GetFluidBlockIndexLevel0(blockPositionLevel1 + blockOffset);
        const uint3 blockIndex = DecodeFluidBlockIndexLevel0(blockIndexLevel0Encoded);

        const uint3 gridIndexOffset = blockIndex * FLUID_BLOCK_SIZE_LEVEL0;
        const uint3 dstGridIndexLocal = srcGridIndex % FLUID_BLOCK_SIZE_LEVEL0;
        const uint3 dstGridIndex = dstGridIndexLocal + gridIndexOffset;

        const int3 velocityEncoded = int3(
            FluidGridLevel0[dstGridIndex + FLUID_GRID_CHANNEL1_OFFSET],
            FluidGridLevel0[dstGridIndex + FLUID_GRID_CHANNEL2_OFFSET],
            FluidGridLevel0[dstGridIndex + FLUID_GRID_CHANNEL3_OFFSET]);
        const float3 velocity = DecodeFluidGridMomentum(velocityEncoded);

        GridVelocity_GSM[i] = velocity;
    }

    GroupMemoryBarrierWithGroupSync();
    
    const bool pingpongFlag = GetFluidParticlePositionPingPongFlag();

    // per particle gather
    for (i = gi; i < particleCount; i += PARTICLE_TO_GRID_KERNEL_SIZE)
    {
        // particles have been sorted into a linear array in particle-to-grid transfer.
        // thus they can be indexed without per-particle indirection.
        const uint particleIndex = particleOffset +i;

        ParticlePositionIndexed position = GetFluidParticlePosition(particleIndex, !pingpongFlag);

        float3 blockSpacePos;
        uint3 gridIndexOffset;
        float3 gridToParticleOffset;
        float3 weights[3];
        CalculateParticleGridTransfer(
            position.Position, blockPositionLevel1, blockSpacePos, gridIndexOffset, gridToParticleOffset,
            weights[0], weights[1], weights[2]);

        const uint gridIndexOffsetEncoded = EncodeFluidGridIndexLevel0(gridIndexOffset, FLUID_BLOCK_PADDING);

        float3x3 affine = 0.0;
        float3 velocity = 0.0;
        for (j = 0; j < 3; j++)
        {
            for (k = 0; k < 3; k++)
            {
                for (l = 0; l < 3; l++)
                {
                    const float weight = weights[j].x * weights[k].y * weights[l].z;

                    const float3 gridToParticle = gridToParticleOffset -float3(j, k, l);

                    const uint gridIndexEncoded = gridIndexOffsetEncoded + EncodeFluidGridIndexLevel0(uint3(j, k, l), FLUID_BLOCK_PADDING);
                    const float3 weightedVelocity = weight * GridVelocity_GSM[gridIndexEncoded];

                    affine += float3x3(
                        gridToParticle * weightedVelocity.x,
                        gridToParticle * weightedVelocity.y,
                        gridToParticle * weightedVelocity.z);

                    velocity += weightedVelocity;
                }
            }
        }

        position.Position += velocity * TIME_STEP;

        SetFluidParticlePosition(particleIndex, position, !pingpongFlag);
        SetFluidParticleAffineVelocity(position.Index, affine, velocity);
    }

    // convert grid of mass to sdf for rendering

    // here're some candidates and their pros/cons:
    //  1. fluid particle -> rendering spheres
    //   + no need to set up data structure
    //   - ray tracing not supported
    //   - unsuitable for collision event
    //  2. fluid grid -> sparse ray marching
    //   + no need to set up data structure
    //   - painful to optimize locality
    //  3. fluid particle -> sdf -> ray marching
    //   - it sounds stupid to read massive particles from distant globa memory once again
    //  4. fluid grid -> sdf -> ray marching
    //   + viable, why not? just do it here
    // more specifically, the user defined iso-mass contour will be the zero-contour of sdf.
    // the resulted narrow-band sdf is expanded or mipmapped afterward.

}

/// end grid to particle

/// begin generate indirect args

uint3 EncodeIndirectArgs(uint count)
{
    return uint3(count % 8192, (count + 8191) / 8192, 1);
}

uint DecodeIndirectArgs(uint3 groupID)
{
    return groupID.x + groupID.y * 8192;
}

extern RWByteAddressBuffer IndirectArgs;

[numthreads(1, 1, 1)]
void GenerateIndirectArgs()
{
    const uint particleCount = GetFluidParticleCount();
    const uint groupCount = (particleCount + SORT_PARTICLE_KERNEL_SIZE - 1) / SORT_PARTICLE_KERNEL_SIZE;

    IndirectArgs.Store3(0, EncodeIndirectArgs(groupCount));

    InvertFluidParticlePositionPingPongFlag();
}

/// end generate indirect args

/// begin add particle

#define ADD_PARTICLES_KERNEL_SIZE 128

CBUFFER_START(AddParticlesParameters)
    uint AddParticleCount;

    float Mass;
CBUFFER_END

extern RWByteAddressBuffer ParticlesToAdd;

groupshared uint AddParticleOffset_GSM;

[numthreads(ADD_PARTICLES_KERNEL_SIZE, 1, 1)]
void AddParticles(uint3 gid : SV_GroupID, uint gi : SV_GroupIndex)
{
    const uint groupParticleCount = min(AddParticleCount - gid.x * ADD_PARTICLES_KERNEL_SIZE, ADD_PARTICLES_KERNEL_SIZE);
    const bool pingpongFlag = GetFluidParticlePositionPingPongFlag();

    if (!gi)
    {
        const uint byteOffset = GetFluidParticleCountByteOffset();
        FluidParticlePositions.InterlockedAdd(byteOffset, groupParticleCount, AddParticleOffset_GSM);
    }

    GroupMemoryBarrierWithGroupSync();

    if (gi < groupParticleCount)
    {
        const uint particleIndex = AddParticleOffset_GSM + gi;

        ParticlePositionIndexed position;
        ParticleProperties properties;

        const float4 word0 = asfloat(ParticlesToAdd.Load4(particleIndex * 24));
        const float2 word1 = asfloat(ParticlesToAdd.Load2(particleIndex * 24 + 16));

        position.Position = word0.xyz;
        properties.SetVelocity(float3(word0.w, word1));

        position.Index = particleIndex;
        properties.Mass = Mass;
        properties.SetZeroAffine();

        SetFluidParticlePosition(particleIndex, position, pingpongFlag);
        SetFluidParticleProperties(particleIndex, properties);
    }
}

/// end add particle
