// here a hybrid eulerian-lagrangian scheme is implemented, specifically a tailored mls-mpm [Hu et al. 2018].
// refer to the links below for detail:
//  - original mls-mpm paper: https://www.yzhu.io/projects/siggraph18_mlsmpm_cpic/index.html
//  - implementation examples: https://nialltl.neocities.org/articles/mpm_guide.html
//
// as for the sparse data structure, there are various choices, e.g., octree, vdb, spgrid.
// after some comparisons, i used something similar to the gspgrid as the sparse data structure.
// some references are available:
//  - original spgrid paper: https://pages.cs.wisc.edu/~sifakis/project_pages/SPGrid.html
//  - gpu optimization of mpm: https://doi.org/10.1145/3272127.3275044
//      - where gspgrid and some inspirng optimization are introduced
//  - taichi programming language: https://doi.org/10.1145/3355089.3356506
//      - special thanks to their benchmarks!
//  - original vdb paper: http://dx.doi.org/10.1145/2487228.2487235
//  - nanovdb implementation: https://github.com/AcademySoftwareFoundation/openvdb/blob/feature/nanovdb/nanovdb/nanovdb/nanovdb/NanoVDB.h

// todo
// 1. scaffold crud
//  1.1 create: add particles with distribution(cube, sphere, particle list, etc.)
//  1.2 delete: remove particles with predicates(volume, property criteria)
//  1.3 retrieve: query particles' properties(lifetime, material, etc.), collision detection
//  1.4 update: update particles' properties
// 2. test affine momentum
// 3. rendering fluids

#pragma use_dxc
// #pragma enable_d3d11_debug_symbols

#pragma kernel GenerateParticleHistogram
#pragma kernel GenerateParticleOffsets
#pragma kernel SortParticles
#pragma kernel ClearFluidGridLevel0
#pragma kernel ClearFluidGridLevel1
#pragma kernel ClearPartitionSums
#pragma kernel ResetBlockCounter
#pragma kernel GenerateIndirectArgs0
#pragma kernel GenerateIndirectArgs1
#pragma kernel GenerateIndirectArgs2
#pragma kernel ParticleToGrid0
#pragma kernel ParticleToGrid1
#pragma kernel SolveGridLevel0
#pragma kernel SolveGridLevel1
#pragma kernel GridToParticle
#pragma kernel AddParticles

#include "FluidData.cginc"
#include "HLSLSupport.cginc"
#include "../Graphics/SDFUtil.cginc"

#define DISABLE_WAVE_SCATTER 0
#define DISABLE_SDF_COLLISION 0

/// begin constant buffer

CBUFFER_START(PhysicsSceneParameters)
    float3 SceneVolumeTexel;
    #define SCENE_VOLUME_TEXEL SceneVolumeTexel

    float Padding0;

    float2 FluidGridSpacing;
    #define FLUID_GRID_SPACING FluidGridSpacing.x
    #define FLUID_GRID_SPACING_INV FluidGridSpacing.y
CBUFFER_END

CBUFFER_START(PhysicsFrameParameters)
    // when the time step is 0, inverse of it should be 0 too
    float2 TimeStep;
    #define TIME_STEP TimeStep.x
    #define TIME_STEP_INV TimeStep.y

    uint CurrentFrameAddParticleCount;

    float Padding1;

    float3 FluidGravity;
    #define GLOBAL_GRAVITY FluidGravity

    float Padding2;

    float3 FluidGridTranslation;

    float Padding3;

    float3 SDFSceneTranslation;
CBUFFER_END

/// end constant buffer

/// begin internal data/funcs

// the maximum number of level 0/level 1 blocks can exceed the limit of single dispatch dimension(e.g. 65535 in dx11)
#define BLOCK_DISPATCH_PARTITION 2
#define FOR_BLOCK_DISPATCH(groupID, level) \
for (uint __gid = uint(groupID.x) * BLOCK_DISPATCH_PARTITION, __hi = min(GetFluidBlockCount(level), __gid + BLOCK_DISPATCH_PARTITION); \
        (groupID.x = __gid) < __hi; __gid++)

#define FOR_BLOCK_DISPATCH_LEVEL0(groupID) FOR_BLOCK_DISPATCH(groupID, 0)
#define FOR_BLOCK_DISPATCH_LEVEL1(groupID) FOR_BLOCK_DISPATCH(groupID, 1)

// layout: { property count, property index* }
// initial value: { 0, x* }
extern RWBuffer<uint> FluidParticlePropertyPool;

uint GetPooledParticlePropertyCountOffset()
{
    return 0;
}

uint GetPooledParticlePropertyOffset(uint index)
{
    return GetPooledParticlePropertyCountOffset() + 1 + index;
}

uint GetPooledParticlePropertyCount()
{
    const uint offset = GetPooledParticlePropertyCountOffset();
    return FluidParticlePropertyPool.Load(offset);
}

void SetPooledParticlePropertyCount(uint count)
{
    const uint offset = GetPooledParticlePropertyCountOffset();
    FluidParticlePropertyPool[offset] = count;
}

uint GetPooledParticleProperty(uint index)
{
    const uint offset = GetPooledParticlePropertyOffset(index);
    return FluidParticlePropertyPool.Load(offset);
}

void SetPooledParticleProperty(uint index, uint propertyIndex)
{
    const uint offset = GetPooledParticlePropertyOffset(index);
    FluidParticlePropertyPool[offset] = propertyIndex;
}

uint AllocatePooledParticleProperty(uint count)
{
    uint lo;
    const uint offset = GetPooledParticlePropertyCountOffset();
    InterlockedAdd(FluidParticlePropertyPool[offset], count, lo);

    return lo;
}

float3 Square(float3 x)
{
    return x * x;
}

float Pow4(float x)
{
    x *= x;
    x *= x;
    return x;
}

float3 GetGridSpacePosition(float3 worldSpacePosition)
{
    return (worldSpacePosition - FluidGridTranslation) * FLUID_GRID_SPACING_INV;
}

int3 GetKernelMinGridIndex(float3 gridSpacePosition)
{
    return int3(ceil(gridSpacePosition - 1.5));
}

bool IsGridInBound(float3 gridSpacePosition)
{
    return all(gridSpacePosition > 0.5 & gridSpacePosition <= float3(FLUID_VIRTUAL_GRID_EXTENT - 1.5));
}

/// end internal data/funcs

/// begin sort particle

#define GENERATE_PARTICLE_HISTOGRAM_KERNEL_SIZE 128

groupshared uint BlockAllocationCountLevel0_GSM;
groupshared uint BlockAllocationCountLevel1_GSM;
groupshared uint3 BlockAllocation_GSM[GENERATE_PARTICLE_HISTOGRAM_KERNEL_SIZE * 8];
groupshared uint3 GridPositionsLevel1_GSM[GENERATE_PARTICLE_HISTOGRAM_KERNEL_SIZE];
groupshared uint PooledParticleProperty_GSM[GENERATE_PARTICLE_HISTOGRAM_KERNEL_SIZE];
groupshared uint PooledParticlePropertyCount_GSM;
groupshared uint PooledParticlePropertyOffset_GSM;

groupshared uint BlockAllocationOffset_GSM;

[numthreads(GENERATE_PARTICLE_HISTOGRAM_KERNEL_SIZE, 1, 1)]
void GenerateParticleHistogram(uint3 tid : SV_DispatchThreadID, uint gi : SV_GroupIndex)
{
    if (!gi)
    {
        BlockAllocationCountLevel0_GSM = 0;
        BlockAllocationCountLevel1_GSM = 0;
        PooledParticlePropertyCount_GSM = 0;
    }

    GroupMemoryBarrierWithGroupSync();

    const bool pingpongFlag = GetFluidParticlePositionPingPongFlag();
    const uint particleCount = GetFluidParticleCount();

    bool valid = tid.x < particleCount;

    // find level 1 blocks to allocate
    ParticlePositionIndexed position;
    uint3 gridPositionLevel1;
    uint3 gridPositionLevel2;
    uint3 gridOffsetLevel1;
    if (valid)
    {
        position = GetFluidParticlePosition(tid.x, pingpongFlag);

        const float3 gridSpacePosition = GetGridSpacePosition(position.Position);

        valid = IsGridInBound(gridSpacePosition);
        if (valid)
        {
            const int3 gridPositionLevel0 = GetKernelMinGridIndex(gridSpacePosition);
            GetFluidGridPositions(gridPositionLevel0, gridPositionLevel1, gridPositionLevel2, gridOffsetLevel1);

            uint acquired = !FLUID_GRID_VALUE_EMPTY;
            InterlockedCompareExchange(
                FluidGridLevel2[gridPositionLevel2],
                FLUID_GRID_VALUE_EMPTY, FLUID_GRID_VALUE_PREEMPTED, acquired);

            if (acquired == FLUID_GRID_VALUE_EMPTY)
            {
                uint index;
                InterlockedAdd(BlockAllocationCountLevel1_GSM, 1, index);
                BlockAllocation_GSM[index] = gridPositionLevel2;
            }

            // allocate adjacent level 1 blocks
            uint i;
            UNITY_UNROLL
            for (i = 1; i < 8; i++)
            {
                const uint3 adjacentGridIndex = uint3(i << 1, i, i >> 1) & 2;
                const uint3 adjacentGridPositionLevel0 = adjacentGridIndex + gridPositionLevel0;

                uint3 adjacentGridPositionLevel1;
                uint3 adjacentGridPositionLevel2;
                uint3 _;
                GetFluidGridPositions(
                    adjacentGridPositionLevel0, adjacentGridPositionLevel1,
                    adjacentGridPositionLevel2, _);

                if (all(adjacentGridPositionLevel2 == gridPositionLevel2))
                    continue;

                acquired = !FLUID_GRID_VALUE_EMPTY;
                InterlockedCompareExchange(
                    FluidGridLevel2[adjacentGridPositionLevel2],
                    FLUID_GRID_VALUE_EMPTY, FLUID_GRID_VALUE_PREEMPTED, acquired);

                if (acquired == FLUID_GRID_VALUE_EMPTY)
                {
                    uint index;
                    InterlockedAdd(BlockAllocationCountLevel1_GSM, 1, index);
                    BlockAllocation_GSM[index] = adjacentGridPositionLevel2;
                }
            }
        }
    }

    GroupMemoryBarrierWithGroupSync();

    // allocate level 1 blocks
    if (!gi)
        InterlockedAdd(FluidBlockParticleOffsets[GetFluidBlockCountOffset(1)], BlockAllocationCountLevel1_GSM, BlockAllocationOffset_GSM);

    GroupMemoryBarrierWithGroupSync();

    // update level 2 grids
    // note that allocated level 2 grid might exceed the particle count, since adjacent level 1 blocks are allocated
    uint i;
    for (i = gi; i < BlockAllocationCountLevel1_GSM; i += GENERATE_PARTICLE_HISTOGRAM_KERNEL_SIZE)
    {
        uint blockIndex = BlockAllocationOffset_GSM + i;
        blockIndex = blockIndex < FLUID_BLOCK_COUNT_LEVEL1 ? EncodeFluidBlockIndex(blockIndex) : FLUID_GRID_VALUE_INVALID;

        FluidGridLevel2[BlockAllocation_GSM[i]] = blockIndex;
    }

    // find level 0 blocks to allocate
    uint3 gridIndexLevel1;
    if (valid)
    {
        uint blockIndexLevel1Linear;
        do
        {
            blockIndexLevel1Linear = FluidGridLevel2[gridPositionLevel2];
        } while (blockIndexLevel1Linear == FLUID_GRID_VALUE_PREEMPTED);

        valid = blockIndexLevel1Linear != FLUID_GRID_VALUE_INVALID;
        if (valid)
        {
            blockIndexLevel1Linear = DecodeFluidBlockIndex(blockIndexLevel1Linear);
            gridIndexLevel1 = GetFluidBlockIndexSpatialLevel1(blockIndexLevel1Linear) * FLUID_BLOCK_SIZE_LEVEL1 + gridOffsetLevel1;

            uint acquired = !FLUID_GRID_VALUE_EMPTY;
            InterlockedCompareExchange(
                FluidGridLevel1[gridIndexLevel1],
                FLUID_GRID_VALUE_EMPTY, FLUID_GRID_VALUE_PREEMPTED, acquired);

            if (acquired == FLUID_GRID_VALUE_EMPTY)
            {
                uint index;
                InterlockedAdd(BlockAllocationCountLevel0_GSM, 1, index);
                BlockAllocation_GSM[index] = gridIndexLevel1;
                GridPositionsLevel1_GSM[index] = gridPositionLevel1;
            }
        }
    }

    GroupMemoryBarrierWithGroupSync();

    // allocate level 0 blocks
    if (!gi)
        InterlockedAdd(FluidBlockParticleOffsets[GetFluidBlockCountOffset(0)], BlockAllocationCountLevel0_GSM, BlockAllocationOffset_GSM);

    GroupMemoryBarrierWithGroupSync();

    // update level 1 grids
    // level 1 grids must be less than or equal to particle count
    if (gi < BlockAllocationCountLevel0_GSM)
    {
        const uint blockIndex = BlockAllocationOffset_GSM + gi;
        const bool allocated = blockIndex < FLUID_BLOCK_COUNT_LEVEL0;
        const uint encodedBlockIndex = allocated ? EncodeFluidBlockIndex(blockIndex) : FLUID_GRID_VALUE_INVALID;
        FluidGridLevel1[BlockAllocation_GSM[gi]] = encodedBlockIndex;

        if (allocated)
        {
            const uint3 gridPosition = GridPositionsLevel1_GSM[gi];
            const uint offset = GetFluidBlockPositionOffset(blockIndex);
            FluidBlockParticleOffsets[offset] = gridPosition.x;
            FluidBlockParticleOffsets[offset +1] = gridPosition.y;
            FluidBlockParticleOffsets[offset +2] = gridPosition.z;
        }
    }

    // add particles to level 0 blocks
    if (valid)
    {
        uint blockIndexLevel0Linear;
        do
        {
            blockIndexLevel0Linear = FluidGridLevel1[gridIndexLevel1];
        } while (blockIndexLevel0Linear == FLUID_GRID_VALUE_PREEMPTED);

        valid = blockIndexLevel0Linear != FLUID_GRID_VALUE_INVALID;
        if (valid)
        {
            blockIndexLevel0Linear = DecodeFluidBlockIndex(blockIndexLevel0Linear);

            uint _;
            const uint offset = GetFluidBlockParticleCountOffset(blockIndexLevel0Linear);
            InterlockedAdd(FluidBlockParticleOffsets[offset], 1, _);
        }
    }

    // pool invalid particles
    if (!valid && tid.x < particleCount)
    {
        uint offset;
        InterlockedAdd(PooledParticlePropertyCount_GSM, 1, offset);
        PooledParticleProperty_GSM[offset] = position.Index;
    }

    GroupMemoryBarrierWithGroupSync();

    // allocate pool
    if (!gi)
        PooledParticlePropertyOffset_GSM = AllocatePooledParticleProperty(PooledParticlePropertyCount_GSM);

    GroupMemoryBarrierWithGroupSync();

    // write pooled particle properties to uav
    if (gi < PooledParticlePropertyCount_GSM)
        SetPooledParticleProperty(PooledParticlePropertyOffset_GSM + gi, PooledParticleProperty_GSM[gi]);
}

#define GENERATE_PARTICLE_OFFSETS_KERNEL_SIZE 128
#define SCAN_MAX_PARTITION_SIZE (GENERATE_PARTICLE_OFFSETS_KERNEL_SIZE * 8)
#define SCAN_PARTITION_VALUE_NULL (~0u)

// layout: { partition count, { partition sum, global inclusive sum }* }
// initial value: { 0, { null, null }*  }
extern globallycoherent RWBuffer<uint> PartitionSums;

uint PreemptPartition()
{
    uint partitionIndex;
    InterlockedAdd(PartitionSums[0], 1, partitionIndex);
    return partitionIndex;
}

uint GetPartitionCountOffset()
{
    return 0;
}

uint GetPartitionSumOffset(uint partitionIndex)
{
    return partitionIndex * 2 + 1;
}

uint GetPartitionInclusiveSumOffset(uint partitionIndex)
{
    return partitionIndex * 2 + 2;
}

uint GetPartitionCount()
{
    return PartitionSums[GetPartitionCountOffset()];
}

void SetPartitionCount(uint count)
{
    PartitionSums[GetPartitionCountOffset()] = count;
}

// note: do not clear partition sums before this value is used up
uint GetTotalBlockParticleCount()
{
    const uint partitionCount = GetPartitionCount();
    if (partitionCount)
        return PartitionSums[GetPartitionInclusiveSumOffset(partitionCount - 1)];
    else
        return 0;
}

groupshared uint PartitionIndex_GSM;
groupshared uint BlockIndexOffset_GSM;
groupshared uint PartitionSize_GSM;
// WaveGetLaneCount() guarantees that 4~128 lanes are presented
// see https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/wavegetlanecount
// thus additional 1/3(calculated by taking limit) size is reserved for hierarchical sum
groupshared uint ParticleCounts_GSM[SCAN_MAX_PARTITION_SIZE + SCAN_MAX_PARTITION_SIZE / 3];
groupshared uint GlobalExclusiveSum_GSM;

[numthreads(GENERATE_PARTICLE_OFFSETS_KERNEL_SIZE, 1, 1)]
void GenerateParticleOffsets(uint3 tid : SV_DispatchThreadID, uint gi : SV_GroupIndex)
{
    if (!gi)
    {
        PartitionIndex_GSM = PreemptPartition();
        BlockIndexOffset_GSM = PartitionIndex_GSM * SCAN_MAX_PARTITION_SIZE;
        GlobalExclusiveSum_GSM = 0;

        const uint blockCount = GetFluidBlockCount(0);
        PartitionSize_GSM = min(blockCount - BlockIndexOffset_GSM, SCAN_MAX_PARTITION_SIZE);
    }

    GroupMemoryBarrierWithGroupSync();

    const uint laneIndex = WaveGetLaneIndex();
    const uint laneCount = WaveGetLaneCount();
    const bool isFirstLane = WaveIsFirstLane();
    // kernel size is assumed to be power of 2
    const uint kernelSize = GENERATE_PARTICLE_OFFSETS_KERNEL_SIZE;
    const uint waveCount = (PartitionSize_GSM + laneCount - 1) / laneCount;
    // max partition size is assumed to be larger than 128
    const uint maxWaveCount = SCAN_MAX_PARTITION_SIZE / laneCount;

    // read particle counts to gsm
    uint i, j;
    for (i = gi; i < PartitionSize_GSM; i += kernelSize)
    {
        const uint particleCount = GetFluidBlockParticleCount(BlockIndexOffset_GSM + i);
        ParticleCounts_GSM[i] = particleCount;
    }

    for (; i < SCAN_MAX_PARTITION_SIZE; i += kernelSize)
    {
        ParticleCounts_GSM[i] = 0;
    }

    GroupMemoryBarrierWithGroupSync();

    // hierarchical group sum
    uint waveSumSrcOffset;
    uint waveSumDstOffset = 0;
    for (i = SCAN_MAX_PARTITION_SIZE; i > 1; i /= laneCount)
    {
        waveSumSrcOffset = waveSumDstOffset;
        waveSumDstOffset += i;

        for (j = gi; j < i; j += kernelSize)
        {
            const uint waveParticleCount = WaveActiveSum(ParticleCounts_GSM[j + waveSumSrcOffset]);
            if (isFirstLane)
                ParticleCounts_GSM[j / laneCount + waveSumDstOffset] = waveParticleCount;
        }

        GroupMemoryBarrierWithGroupSync();
    }

    const uint partitionSum = ParticleCounts_GSM[waveSumDstOffset];

    // write group sum to uav
    if (!gi)
    {
        PartitionSums[GetPartitionSumOffset(PartitionIndex_GSM)] = partitionSum;

        // used in the hierarchical exclusive prefix sum below
        ParticleCounts_GSM[waveSumDstOffset] = 0;
    }

    // look back to calculate exclusive prefix sum
    if (gi < laneCount)
    {
        for (i = gi; i - gi < PartitionIndex_GSM; i += laneCount)
        {
            const bool valid = i < PartitionIndex_GSM;
            const uint lookbackIndex = PartitionIndex_GSM - i - 1;

            // look back with polling
            uint lookbackSum;
            uint minInclusiveSumLane;
            while (true)
            {
                // no wave divergence until here
                uint lookbackInclusiveSum = SCAN_PARTITION_VALUE_NULL;
                if (valid)
                    lookbackInclusiveSum = PartitionSums[GetPartitionInclusiveSumOffset(lookbackIndex)];

                minInclusiveSumLane = WaveActiveMin(lookbackInclusiveSum != SCAN_PARTITION_VALUE_NULL ? gi : 128);
                if (gi == minInclusiveSumLane)
                    GlobalExclusiveSum_GSM += lookbackInclusiveSum;

                lookbackSum = 0;
                if (gi < minInclusiveSumLane)
                    lookbackSum = PartitionSums[GetPartitionSumOffset(lookbackIndex)];

                // stop polling if all the lanes have retrieved required value
                const bool isValidSum = !WaveActiveAnyTrue(lookbackSum == SCAN_PARTITION_VALUE_NULL);
                if (isValidSum)
                    break;
            }

            const uint waveSum = WaveActiveSum(lookbackSum);
            if (!gi)
                GlobalExclusiveSum_GSM += waveSum;

            if (minInclusiveSumLane < 128)
                break;
        }
    }

    GroupMemoryBarrierWithGroupSync();

    if (!gi)
        PartitionSums[GetPartitionInclusiveSumOffset(PartitionIndex_GSM)] = partitionSum + GlobalExclusiveSum_GSM;

    // hierarchical exclusive prefix sum
    i = waveSumDstOffset -waveSumSrcOffset;
    while (i <= SCAN_MAX_PARTITION_SIZE)
    {
        for (j = gi; j < i; j += kernelSize)
        {
            const uint exclusiveSum = WavePrefixSum(ParticleCounts_GSM[j + waveSumSrcOffset]);
            const uint prevWaveExclusiveSum = ParticleCounts_GSM[j / laneCount + waveSumDstOffset];

            ParticleCounts_GSM[j + waveSumSrcOffset] = prevWaveExclusiveSum + exclusiveSum;
        }

        waveSumDstOffset = waveSumSrcOffset;
        i *= laneCount;
        waveSumSrcOffset -= i;

        GroupMemoryBarrierWithGroupSync();
    }

    for (i = gi; i < PartitionSize_GSM; i += kernelSize)
    {
        const uint blockIndex = BlockIndexOffset_GSM + i;
        FluidBlockParticleOffsets[GetFluidBlockParticleCountOffset(blockIndex)] = 0;
        SetFluidBlockParticleCountPrefixSum(blockIndex, GlobalExclusiveSum_GSM + ParticleCounts_GSM[i]);
    }
}

#define SORT_PARTICLES_KERNEL_SIZE 128

[numthreads(SORT_PARTICLES_KERNEL_SIZE, 1, 1)]
void SortParticles(uint3 tid : SV_DispatchThreadID)
{
    const uint particleCount = GetFluidParticleCount();

    if (tid.x >= particleCount)
        return;

    const bool pingpongFlag = GetFluidParticlePositionPingPongFlag();

    const ParticlePositionIndexed position = GetFluidParticlePosition(tid.x, pingpongFlag);
    const float3 gridSpacePosition = GetGridSpacePosition(position.Position);
    if (!IsGridInBound(gridSpacePosition))
        return;

    const int3 gridPositionLevel0 = GetKernelMinGridIndex(gridSpacePosition);

    uint3 gridPositionLevel2;
    uint3 gridOffsetLevel1;
    GetFluidGridPositions(gridPositionLevel0, gridPositionLevel2, gridOffsetLevel1);

    uint blockIndexLevel1Linear = FluidGridLevel2[gridPositionLevel2];
    if (blockIndexLevel1Linear == FLUID_GRID_VALUE_INVALID)
        return;

    blockIndexLevel1Linear = DecodeFluidBlockIndex(blockIndexLevel1Linear);
    const uint3 blockIndexLevel1Spatial = GetFluidBlockIndexSpatialLevel1(blockIndexLevel1Linear);
    const uint3 gridIndexLevel1Spatial = blockIndexLevel1Spatial * FLUID_BLOCK_SIZE_LEVEL1 + gridOffsetLevel1;

    uint blockIndexLevel0Linear = FluidGridLevel1[gridIndexLevel1Spatial];
    if (blockIndexLevel0Linear == FLUID_GRID_VALUE_INVALID)
        return;

    blockIndexLevel0Linear = DecodeFluidBlockIndex(blockIndexLevel0Linear);
    const uint particleCountOffset = GetFluidBlockParticleCountOffset(blockIndexLevel0Linear);

    uint dstIndex;
    InterlockedAdd(FluidBlockParticleOffsets[particleCountOffset], 1, dstIndex);
    dstIndex += GetFluidBlockParticleCountPrefixSum(blockIndexLevel0Linear);

    SetFluidParticlePosition(dstIndex, position, !pingpongFlag);
}

/// end sort particle

/// begin clear fluid data

#define CLEAR_FLUID_GRID_LEVEL0_KERNEL_SIZE FLUID_BLOCK_SIZE_LEVEL0

[numthreads(CLEAR_FLUID_GRID_LEVEL0_KERNEL_SIZE, CLEAR_FLUID_GRID_LEVEL0_KERNEL_SIZE, CLEAR_FLUID_GRID_LEVEL0_KERNEL_SIZE)]
void ClearFluidGridLevel0(uint3 gid : SV_GroupID, uint3 gtid : SV_GroupThreadID, uint gi : SV_GroupIndex)
{
    FOR_BLOCK_DISPATCH_LEVEL0(gid)
    {
        const uint3 blockIndexSpatial = GetFluidBlockIndexSpatialLevel0(gid.x);
        const uint3 gridOffset = blockIndexSpatial * FLUID_BLOCK_SIZE_LEVEL0 + gtid;
        FluidGridLevel0[gridOffset +FLUID_GRID_CHANNEL0_OFFSET] = 0;
        FluidGridLevel0[gridOffset +FLUID_GRID_CHANNEL1_OFFSET] = 0;
        FluidGridLevel0[gridOffset +FLUID_GRID_CHANNEL2_OFFSET] = 0;
        FluidGridLevel0[gridOffset +FLUID_GRID_CHANNEL3_OFFSET] = 0;
        FluidGridLevel0[gridOffset +FLUID_GRID_CHANNEL4_OFFSET] = 0;

        if (!gi)
            FluidBlockParticleOffsets[GetFluidBlockParticleCountOffset(gid.x)] = 0;
    }
}

#define CLEAR_FLUID_GRID_LEVEL1_KERNEL_SIZE FLUID_BLOCK_SIZE_LEVEL1

[numthreads(CLEAR_FLUID_GRID_LEVEL1_KERNEL_SIZE, CLEAR_FLUID_GRID_LEVEL1_KERNEL_SIZE, CLEAR_FLUID_GRID_LEVEL1_KERNEL_SIZE)]
void ClearFluidGridLevel1(uint3 gid : SV_GroupID, uint3 gtid : SV_GroupThreadID)
{
    FOR_BLOCK_DISPATCH_LEVEL1(gid)
    {
        const uint3 blockIndex = GetFluidBlockIndexSpatialLevel1(gid.x);
        const uint3 gridOffset = blockIndex * FLUID_BLOCK_SIZE_LEVEL1 + gtid;
        FluidGridLevel1[gridOffset +FLUID_GRID_CHANNEL0_OFFSET] = FLUID_GRID_VALUE_EMPTY;
        FluidGridLevel1[gridOffset +FLUID_GRID_CHANNEL1_OFFSET] = 0;
        FluidGridLevel1[gridOffset +FLUID_GRID_CHANNEL2_OFFSET] = 0;
        FluidGridLevel1[gridOffset +FLUID_GRID_CHANNEL3_OFFSET] = 0;
        FluidGridLevel1[gridOffset +FLUID_GRID_CHANNEL4_OFFSET] = 0;
    }
}

#define CLEAR_PARTITION_SUMS_KERNEL_SIZE 128

[numthreads(CLEAR_PARTITION_SUMS_KERNEL_SIZE, 1, 1)]
void ClearPartitionSums(uint3 tid : SV_DispatchThreadID)
{
    if (tid.x < GetPartitionCount())
    {
        uint offset = GetPartitionSumOffset(tid.x);
        PartitionSums[offset] = SCAN_PARTITION_VALUE_NULL;

        offset = GetPartitionInclusiveSumOffset(tid.x);
        PartitionSums[offset] = SCAN_PARTITION_VALUE_NULL;
    }
}

[numthreads(1, 1, 1)]
void ResetBlockCounter()
{
    SetFluidBlockCount(0, 0);
    SetFluidBlockCount(1, 0);
}

/// end clear fluid data

/// begin indirect args

// layout: {
//   generate particle histogram group count, indirect args{2},
//   sort particles group count, indirect args{2},
//   clear partition sums group count, indirect args{2}
//   indirect arg, particle count, indirect args{2}
//   level 0 block dispatch group count, indirect args{3},
//   level 1 block dispatch group count, indirect args{3},
// }
// initial value: { x, 1, 1, x, 1, 1, x, 1, 1, 1, x, 0, 0, x, 1, 1, x, 1, 1 }
extern RWBuffer<uint> IndirectArgs;

uint GetGroupCount(uint nelem, uint kernelSize)
{
    return (nelem + kernelSize - 1) / kernelSize;
}

[numthreads(1, 1, 1)]
void GenerateIndirectArgs0()
{
    const uint prevParticleCount = GetFluidParticleCount();
    const uint particleCount = min(prevParticleCount + CurrentFrameAddParticleCount, FLUID_MAX_PARTICLE_COUNT);
    IndirectArgs[0] = GetGroupCount(particleCount, GENERATE_PARTICLE_HISTOGRAM_KERNEL_SIZE);
    IndirectArgs[3] = GetGroupCount(particleCount, SORT_PARTICLES_KERNEL_SIZE);
    SetFluidParticleCount(particleCount);

    const uint partitionCount = GetPartitionCount();
    IndirectArgs[6] = GetGroupCount(partitionCount, CLEAR_PARTITION_SUMS_KERNEL_SIZE);
    SetPartitionCount(0);

    const uint prevPoolSize = GetPooledParticlePropertyCount();
    const uint newPoolSize = prevPoolSize - min(particleCount - prevParticleCount, prevPoolSize);
    SetPooledParticlePropertyCount(newPoolSize);

    const uint blockCountLevel0 = GetFluidBlockCount(0);
    IndirectArgs[13] = GetGroupCount(blockCountLevel0, BLOCK_DISPATCH_PARTITION);

    const uint blockCountLevel1 = GetFluidBlockCount(1);
    IndirectArgs[16] = GetGroupCount(blockCountLevel1, BLOCK_DISPATCH_PARTITION);
}

[numthreads(1, 1, 1)]
void GenerateIndirectArgs1()
{
    const uint blockCountLevel0 = GetFluidBlockCount(0);
    IndirectArgs[0] = GetGroupCount(blockCountLevel0, SCAN_MAX_PARTITION_SIZE);
    IndirectArgs[13] = GetGroupCount(blockCountLevel0, BLOCK_DISPATCH_PARTITION);

    const uint blockCountLevel1 = GetFluidBlockCount(1);
    IndirectArgs[16] = GetGroupCount(blockCountLevel1, BLOCK_DISPATCH_PARTITION);
}

[numthreads(1, 1, 1)]
void GenerateIndirectArgs2()
{
    const bool pingpongFlag = GetFluidParticlePositionPingPongFlag();
    SetFluidParticlePositionPingPongFlag(!pingpongFlag);

    const uint particleCount = GetTotalBlockParticleCount();
    IndirectArgs[10] = particleCount;
    SetFluidParticleCount(particleCount);
}

/// end indirect args

/// begin particle to grid

#define PARTICLE_TO_GRID_KERNEL_SIZE 128

#define FLUID_BLOCK_PADDING 2
#define FLUID_BLOCK_SIZE_LEVEL0_PADDED (FLUID_BLOCK_SIZE_LEVEL0 + FLUID_BLOCK_PADDING)
#define FLUID_BLOCK_GRID_COUNT_LEVEL0_PADDED (FLUID_BLOCK_SIZE_LEVEL0_PADDED * FLUID_BLOCK_SIZE_LEVEL0_PADDED * FLUID_BLOCK_SIZE_LEVEL0_PADDED)

void CalculateWeights(float3 gridToParticle, out float3 weight0, out float3 weight1, out float3 weight2)
{
    weight0 = 0.5 * Square(1.5 - gridToParticle);
    weight1 = 0.75 - Square(gridToParticle - 1.0);
    weight2 = 0.5 * Square(gridToParticle - 0.5);
}

void CalculateParticleGridTransfer(
    float3 gridSpacePosition, uint3 gridPositionLevel1, out uint3 gridIndex,
    out float3 gridToParticle, out float3 weight0, out float3 weight1, out float3 weight2)
{
    gridIndex = uint3(GetKernelMinGridIndex(gridSpacePosition)) % FLUID_BLOCK_SIZE_LEVEL0;

    const uint3 gridPositionLevel0 = gridPositionLevel1 * FLUID_BLOCK_SIZE_LEVEL0 + gridIndex;
    gridToParticle = gridSpacePosition - gridPositionLevel0;

    CalculateWeights(gridToParticle, weight0, weight1, weight2);
}

void WaveGetMaxInterval(bool flag, out uint interval, out uint maxInterval)
{
    const uint laneIndex = WaveGetLaneIndex();
    const uint laneCount = WaveGetLaneCount();

    interval = 1;
    uint stride = 1;
    while (stride < laneCount)
    {
        const uint dstLane = laneIndex + interval;
        const bool dstFlag = WaveReadLaneAt(flag, dstLane);
        const uint dstInterval = WaveReadLaneAt(interval, dstLane);

        if (dstLane < laneCount && !dstFlag)
            interval += dstInterval;

        stride *= 2;
    }

    maxInterval = WaveActiveMax(interval);
}

groupshared uint3 GridPositionLevel1_GSM;
groupshared uint ParticleCount_GSM;
groupshared uint ParticleOffset_GSM;
// size: 16 * 216 = 3456 bytes
groupshared int4 FluidGrid_GSM[FLUID_BLOCK_GRID_COUNT_LEVEL0_PADDED];
// size: 4 * 216 = 864 bytes
groupshared int SDFGrid_GSM[FLUID_BLOCK_GRID_COUNT_LEVEL0_PADDED];
groupshared uint AdjacentBlockIndexLevel1_GSM[8];

[numthreads(PARTICLE_TO_GRID_KERNEL_SIZE, 1, 1)]
void ParticleToGrid0(uint3 gid : SV_GroupID, uint gi : SV_GroupIndex)
{
    FOR_BLOCK_DISPATCH_LEVEL0(gid)
    {
        uint i, j, k, l;

        // initialize grid gsm
        for (i = gi; i < FLUID_BLOCK_GRID_COUNT_LEVEL0_PADDED; i += PARTICLE_TO_GRID_KERNEL_SIZE)
        {
            FluidGrid_GSM[i] = int4(0, 0, 0, 0);

            // max sdf
            SDFGrid_GSM[i] = FLUID_GRID_ENCODED_VALUE_MAX;
        }

        if (!gi)
        {
            GetFluidBlockInfo(gid.x, GridPositionLevel1_GSM, ParticleCount_GSM, ParticleOffset_GSM);
        }

        GroupMemoryBarrierWithGroupSync();

        const bool pingpongFlag = GetFluidParticlePositionPingPongFlag();

        // per particle scatter
        for (i = gi; i < ParticleCount_GSM; i += PARTICLE_TO_GRID_KERNEL_SIZE)
        {
            // read particle from arrays attached to block
            const uint particleIndex = i + ParticleOffset_GSM;
            const ParticlePositionIndexed position = GetFluidParticlePosition(particleIndex, pingpongFlag);
            const ParticleProperty property = GetFluidParticleProperty(position.Index);

            const float3 gridSpacePosition = GetGridSpacePosition(position.Position);

            const float3 velocity = property.GetVelocity();
            const float3x3 affine = property.GetAffine();

            // calculate indices and weights
            uint3 gridIndex;
            float3 gridToParticle;
            float3 weights[3];
            CalculateParticleGridTransfer(
                gridSpacePosition, GridPositionLevel1_GSM, gridIndex, gridToParticle,
                weights[0], weights[1], weights[2]);

            const uint gridIndexEncoded = GetFluidBlockGridIndexLinearLevel0(gridIndex, FLUID_BLOCK_PADDING);

            #if !DISABLE_WAVE_SCATTER
                // preparation to handle inter-wave conflicts
                const uint laneIndex = WaveGetLaneIndex();
                const bool isLo = gridIndexEncoded != WaveReadLaneAt(gridIndexEncoded, max(1, laneIndex) - 1) || !laneIndex;

                uint interval, intervalMax;
                WaveGetMaxInterval(isLo, interval, intervalMax);
            #endif

            // simplified mls-mpm p2g
            UNITY_UNROLL
            for (j = 0; j < 3; j++)
            {
                UNITY_UNROLL
                for (k = 0; k < 3; k++)
                {
                    UNITY_UNROLL
                    for (l = 0; l < 3; l++)
                    {
                        const float weight = weights[j].x * weights[k].y * weights[l].z;

                        const float3 x = (float3(j, k, l) - gridToParticle) * FLUID_GRID_SPACING;
                        const float3 affineVelocity = mul(affine, x);

                        float4 massMomentum;
                        massMomentum.x = weight * property.Mass;
                        massMomentum.yzw = massMomentum.x * (velocity + affineVelocity);
                        float sdf = length(x) - FLUID_PARTICLE_RADIUS;

                        #if !DISABLE_WAVE_SCATTER
                            uint stride = 1;
                            while (stride < intervalMax)
                            {
                                const uint dstLane = laneIndex + stride;
                                const float4 tempMassMomentum = WaveReadLaneAt(massMomentum, dstLane);
                                const float tempSDF = WaveReadLaneAt(sdf, dstLane);

                                if (stride < interval)
                                {
                                    massMomentum += tempMassMomentum;
                                    sdf = SmoothMin(sdf, tempSDF);
                                }

                                stride *= 2;
                            }

                            if (!isLo)
                                continue;
                        #endif

                        const uint dstGridIndexEncoded = gridIndexEncoded + GetFluidBlockGridIndexLinearLevel0(uint3(j, k, l), FLUID_BLOCK_PADDING);
                        const int massEncoded = EncodeFluidGridMass(massMomentum.x);
                        const int3 momentumEncoded = EncodeFluidGridMomentum(massMomentum.yzw);
                        const int sdfEncoded = EncodeFluidGridSDF(sdf);

                        // currently 4-element atomic add is not spported
                        int _;
                        InterlockedAdd(FluidGrid_GSM[dstGridIndexEncoded].x, massEncoded, _);
                        InterlockedAdd(FluidGrid_GSM[dstGridIndexEncoded].y, momentumEncoded.x, _);
                        InterlockedAdd(FluidGrid_GSM[dstGridIndexEncoded].z, momentumEncoded.y, _);
                        InterlockedAdd(FluidGrid_GSM[dstGridIndexEncoded].w, momentumEncoded.z, _);
                        InterlockedMin(SDFGrid_GSM[dstGridIndexEncoded], sdfEncoded, _);
                    }
                }
            }
        }

        GroupMemoryBarrierWithGroupSync();

        // write to current block
        const uint3 dstGridOffset = GetFluidBlockIndexSpatialLevel0(gid.x) * FLUID_BLOCK_SIZE_LEVEL0;
        for (i = gi; i < FLUID_BLOCK_GRID_COUNT_LEVEL0; i += PARTICLE_TO_GRID_KERNEL_SIZE)
        {
            const uint3 srcGridIndex = GetFluidBlockGridIndexSpatialLevel0(i);
            const uint loadGridIndex = GetFluidBlockGridIndexLinearLevel0(srcGridIndex, FLUID_BLOCK_PADDING);

            const uint3 dstGridIndex = dstGridOffset +srcGridIndex;

            const int4 gridValue = FluidGrid_GSM[loadGridIndex];

            int _;
            InterlockedAdd(FluidGridLevel0[dstGridIndex + FLUID_GRID_CHANNEL0_OFFSET], gridValue.x, _);
            InterlockedAdd(FluidGridLevel0[dstGridIndex + FLUID_GRID_CHANNEL1_OFFSET], gridValue.y, _);
            InterlockedAdd(FluidGridLevel0[dstGridIndex + FLUID_GRID_CHANNEL2_OFFSET], gridValue.z, _);
            InterlockedAdd(FluidGridLevel0[dstGridIndex + FLUID_GRID_CHANNEL3_OFFSET], gridValue.w, _);
        }

        if (gi < 8)
        {
            const uint3 adjacentGridIndex = uint3(gi & 1, (gi >> 1) & 1, gi >> 2);
            const uint3 adjacentGridPositionLevel1 = adjacentGridIndex + GridPositionLevel1_GSM;
            const uint3 adjacentGridPositionLevel2 = adjacentGridPositionLevel1 / FLUID_BLOCK_SIZE_LEVEL1;
            AdjacentBlockIndexLevel1_GSM[gi] = FluidGridLevel2[adjacentGridPositionLevel2];
        }

        GroupMemoryBarrierWithGroupSync();

        // write to adjacent blocks
        UNITY_UNROLL
        for (i = 1; i < 8; i++)
        {
            // query adjacent block
            const uint3 adjacentGridIndex = uint3(i & 1, (i >> 1) & 1, i >> 2);
            const uint3 adjacentGridPositionLevel1 = adjacentGridIndex + GridPositionLevel1_GSM;
            const uint3 adjacentGridOffsetLevel1 = adjacentGridPositionLevel1 % FLUID_BLOCK_SIZE_LEVEL1;

            const uint adjacentBlockIndexLevel1Encoded = AdjacentBlockIndexLevel1_GSM[i];

            // level 2 doesn't have "ghost cells"(term used in original spgrid paper)
            // thus, if no level 1 block is allocated, grid values are just discarded
            if (IsValidEncodedFluidBlockIndex(adjacentBlockIndexLevel1Encoded))
            {
                const uint3 subblockMin = adjacentGridIndex * FLUID_BLOCK_SIZE_LEVEL0;
                const uint3 subblockMax = min(
                    subblockMin + FLUID_BLOCK_SIZE_LEVEL0, FLUID_BLOCK_SIZE_LEVEL0_PADDED);
                const uint3 subblockSize = subblockMax - subblockMin;

                const uint3 srcGridIndex = GetGridIndexSpatial(gi, subblockSize.xy);
                if (all(srcGridIndex < subblockSize))
                {
                    const uint loadGridIndex = GetFluidBlockGridIndexLinearLevel0(subblockMin + srcGridIndex, FLUID_BLOCK_PADDING);

                    const int4 gridValue = FluidGrid_GSM[loadGridIndex];
                    const int sdf = SDFGrid_GSM[loadGridIndex];

                    const uint3 adjacentBlockIndexLevel1 = GetFluidBlockIndexSpatialLevel1(DecodeFluidBlockIndex(adjacentBlockIndexLevel1Encoded));
                    const uint3 adjacentGridIndexLevel1 = adjacentBlockIndexLevel1 * FLUID_BLOCK_SIZE_LEVEL1 + adjacentGridOffsetLevel1;
                    const uint3 adjacentBlockIndexLevel0Encoded = FluidGridLevel1[adjacentGridIndexLevel1];

                    if (IsValidEncodedFluidBlockIndex(adjacentBlockIndexLevel0Encoded))
                    {
                        const uint3 adjacentBlockIndexLevel0 = GetFluidBlockIndexSpatialLevel0(DecodeFluidBlockIndex(adjacentBlockIndexLevel0Encoded));
                        const uint3 dstGridIndex = adjacentBlockIndexLevel0 * FLUID_BLOCK_SIZE_LEVEL0 + srcGridIndex;

                        int _;
                        InterlockedAdd(FluidGridLevel0[dstGridIndex + FLUID_GRID_CHANNEL0_OFFSET], gridValue.x, _);
                        InterlockedAdd(FluidGridLevel0[dstGridIndex + FLUID_GRID_CHANNEL1_OFFSET], gridValue.y, _);
                        InterlockedAdd(FluidGridLevel0[dstGridIndex + FLUID_GRID_CHANNEL2_OFFSET], gridValue.z, _);
                        InterlockedAdd(FluidGridLevel0[dstGridIndex + FLUID_GRID_CHANNEL3_OFFSET], gridValue.w, _);
                        InterlockedMin(FluidGridLevel0[dstGridIndex + FLUID_GRID_CHANNEL4_OFFSET], sdf, _);
                    }
                    else
                    {
                        // if the level 0 is not allocated, add quantity to the coarser grid
                        #if !DISABLE_WAVE_SCATTER
                            const int4 gridValueSum = WaveActiveSum(gridValue);
                            if (!gi)
                            {
                                int _;
                                InterlockedAdd(FluidGridLevel1[adjacentGridIndexLevel1 + FLUID_GRID_CHANNEL0_OFFSET], gridValueSum.x, _);
                                InterlockedAdd(FluidGridLevel1[adjacentGridIndexLevel1 + FLUID_GRID_CHANNEL1_OFFSET], gridValueSum.y, _);
                                InterlockedAdd(FluidGridLevel1[adjacentGridIndexLevel1 + FLUID_GRID_CHANNEL2_OFFSET], gridValueSum.z, _);
                                InterlockedAdd(FluidGridLevel1[adjacentGridIndexLevel1 + FLUID_GRID_CHANNEL3_OFFSET], gridValueSum.w, _);
                                InterlockedMin(FluidGridLevel1[adjacentGridIndexLevel1 + FLUID_GRID_CHANNEL4_OFFSET], sdf, _);
                            }
                        #else
                            int _;
                            InterlockedAdd(FluidGridLevel1[adjacentGridIndexLevel1 + FLUID_GRID_CHANNEL0_OFFSET], gridValue.x, _);
                            InterlockedAdd(FluidGridLevel1[adjacentGridIndexLevel1 + FLUID_GRID_CHANNEL1_OFFSET], gridValue.y, _);
                            InterlockedAdd(FluidGridLevel1[adjacentGridIndexLevel1 + FLUID_GRID_CHANNEL2_OFFSET], gridValue.z, _);
                            InterlockedAdd(FluidGridLevel1[adjacentGridIndexLevel1 + FLUID_GRID_CHANNEL3_OFFSET], gridValue.w, _);
                            InterlockedMin(FluidGridLevel1[adjacentGridIndexLevel1 + FLUID_GRID_CHANNEL4_OFFSET], sdf, _);
                        #endif
                    }
                }
            }
        }
    }
}

// size: 12 * 216 = 2592 bytes
groupshared int3 MomentumGridEncoded_GSM[FLUID_BLOCK_GRID_COUNT_LEVEL0_PADDED];
// size: 4 * 216 = 864 bytes
groupshared float MassGrid_GSM[FLUID_BLOCK_GRID_COUNT_LEVEL0_PADDED];

[numthreads(PARTICLE_TO_GRID_KERNEL_SIZE, 1, 1)]
void ParticleToGrid1(uint3 gid : SV_GroupID, uint gi : SV_GroupIndex)
{
    FOR_BLOCK_DISPATCH_LEVEL0(gid)
    {
        if (!gi)
        {
            GetFluidBlockInfo(gid.x, GridPositionLevel1_GSM, ParticleCount_GSM, ParticleOffset_GSM);
        }

        uint i, j, k, l;

        for (i = gi; i < FLUID_BLOCK_GRID_COUNT_LEVEL0_PADDED; i += PARTICLE_TO_GRID_KERNEL_SIZE)
        {
            MomentumGridEncoded_GSM[i] = int3(0, 0, 0);
        }

        // read mass from current block
        const uint3 srcGridOffset = GetFluidBlockIndexSpatialLevel0(gid.x) * FLUID_BLOCK_SIZE_LEVEL0;
        for (i = gi; i < FLUID_BLOCK_GRID_COUNT_LEVEL0; i += PARTICLE_TO_GRID_KERNEL_SIZE)
        {
            const uint3 dstGridIndex = GetFluidBlockGridIndexSpatialLevel0(i);
            const uint storeGridIndex = GetFluidBlockGridIndexLinearLevel0(dstGridIndex, FLUID_BLOCK_PADDING);
            const uint3 srcGridIndex = srcGridOffset +dstGridIndex;

            const int massEncoded = FluidGridLevel0[srcGridIndex + FLUID_GRID_CHANNEL0_OFFSET];
            MassGrid_GSM[storeGridIndex] = DecodeFluidGridMass(massEncoded);
        }

        // indices of adjacent blocks to load
        if (gi < 8)
        {
            const uint3 adjacentGridIndex = uint3(gi & 1, (gi >> 1) & 1, gi >> 2);
            const uint3 adjacentGridPositionLevel1 = adjacentGridIndex + GridPositionLevel1_GSM;
            const uint3 adjacentGridPositionLevel2 = adjacentGridPositionLevel1 / FLUID_BLOCK_SIZE_LEVEL1;
            AdjacentBlockIndexLevel1_GSM[gi] = FluidGridLevel2[adjacentGridPositionLevel2];
        }

        GroupMemoryBarrierWithGroupSync();

        // read mass from adjacent blocks
        UNITY_UNROLL
        for (i = 1; i < 8; i++)
        {
            // query adjacent block
            const uint3 adjacentGridIndex = uint3(i & 1, (i >> 1) & 1, i >> 2);
            const uint3 adjacentGridPositionLevel1 = adjacentGridIndex + GridPositionLevel1_GSM;
            const uint3 adjacentGridOffsetLevel1 = adjacentGridPositionLevel1 % FLUID_BLOCK_SIZE_LEVEL1;

            const uint adjacentBlockIndexLevel1Encoded = AdjacentBlockIndexLevel1_GSM[i];

            const uint3 subblockMin = adjacentGridIndex * FLUID_BLOCK_SIZE_LEVEL0;
            const uint3 subblockMax = min(
                subblockMin + FLUID_BLOCK_SIZE_LEVEL0, FLUID_BLOCK_SIZE_LEVEL0_PADDED);
            const uint3 subblockSize = subblockMax - subblockMin;
            const uint subblockGridCount = subblockSize.x * subblockSize.y * subblockSize.z;

            const uint3 dstGridIndex = GetGridIndexSpatial(gi, subblockSize.xy);
            const uint storeGridIndex = GetFluidBlockGridIndexLinearLevel0(subblockMin + dstGridIndex, FLUID_BLOCK_PADDING);

            if (gi < subblockGridCount)
            {
                if (IsValidEncodedFluidBlockIndex(adjacentBlockIndexLevel1Encoded))
                {
                    const uint3 adjacentBlockIndexLevel1 = GetFluidBlockIndexSpatialLevel1(DecodeFluidBlockIndex(adjacentBlockIndexLevel1Encoded));
                    const uint3 adjacentGridIndexLevel1 = adjacentBlockIndexLevel1 * FLUID_BLOCK_SIZE_LEVEL1 + adjacentGridOffsetLevel1;
                    const int adjacentBlockIndexLevel0Encoded = FluidGridLevel1[adjacentGridIndexLevel1];

                    int massEncoded;
                    if (IsValidEncodedFluidBlockIndex(adjacentBlockIndexLevel0Encoded))
                    {
                        const uint3 adjacentBlockIndexLevel0 = GetFluidBlockIndexSpatialLevel0(DecodeFluidBlockIndex(adjacentBlockIndexLevel0Encoded));
                        const uint3 srcGridIndex = adjacentBlockIndexLevel0 * FLUID_BLOCK_SIZE_LEVEL0 + dstGridIndex;

                        massEncoded = FluidGridLevel0[srcGridIndex + FLUID_GRID_CHANNEL0_OFFSET];
                    }
                    else
                    {
                        // if the level 0 block is not allocated, reinterpret the coarser grid
                        massEncoded = adjacentBlockIndexLevel0Encoded / subblockGridCount;
                    }

                    MassGrid_GSM[storeGridIndex] = DecodeFluidGridMass(massEncoded);
                }
                else
                {
                    // otherwise extrapolate from current block
                    const uint indexClamped = clamp(storeGridIndex, 0, FLUID_BLOCK_SIZE_LEVEL0);
                    const uint index = GetFluidBlockGridIndexLinearLevel0(indexClamped, FLUID_BLOCK_PADDING);
                    MassGrid_GSM[storeGridIndex] = MassGrid_GSM[index];
                }
            }
        }

        GroupMemoryBarrierWithGroupSync();

        const bool pingpongFlag = GetFluidParticlePositionPingPongFlag();

        // read particles from current block
        for (i = gi; i < ParticleCount_GSM; i += PARTICLE_TO_GRID_KERNEL_SIZE)
        {
            // particles have been sorted into a linear array in particle-to-grid transfer.
            // thus they can be indexed without per-particle indirection.
            const uint particleIndex = ParticleOffset_GSM + i;

            ParticlePositionIndexed position = GetFluidParticlePosition(particleIndex, pingpongFlag);
            ParticleProperty property = GetFluidParticleProperty(position.Index);

            const float3 gridSpacePosition = GetGridSpacePosition(position.Position);

            uint3 gridIndexOffset;
            float3 gridToParticleOffset;
            float3 weights[3];
            CalculateParticleGridTransfer(
                gridSpacePosition, GridPositionLevel1_GSM, gridIndexOffset, gridToParticleOffset,
                weights[0], weights[1], weights[2]);

            const uint gridIndexOffsetEncoded = GetFluidBlockGridIndexLinearLevel0(gridIndexOffset, FLUID_BLOCK_PADDING);

            float density = 0.0;
            UNITY_UNROLL
            for (j = 0; j < 3; j++)
            {
                UNITY_UNROLL
                for (k = 0; k < 3; k++)
                {
                    UNITY_UNROLL
                    for (l = 0; l < 3; l++)
                    {
                        const float weight = weights[j].x * weights[k].y * weights[l].z;
                        const uint gridIndexEncoded = gridIndexOffsetEncoded + GetFluidBlockGridIndexLinearLevel0(uint3(j, k, l), FLUID_BLOCK_PADDING);
                        const float mass = MassGrid_GSM[gridIndexEncoded];
                        density += weight * mass;
                    }
                }
            }

            // tait-murnaghan equation of state
            const float pressure = (FLUID_EOS_BULK_MODULUS * 0.25) * Pow4(density * (1.0 / FLUID_EOS_REST_DENSITY));
            const float volume = property.Mass / density;
            const float3x3 affine = property.GetAffine();

            float3x3 stress = FLUID_VISCOSITY_COEFFICIENT * (affine + transpose(affine));
            stress._m00 -= pressure;
            stress._m11 -= pressure;
            stress._m22 -= pressure;

            const float3x3 c = 3.0 * TIME_STEP * volume * stress;

            #if !DISABLE_WAVE_SCATTER
                // preparation to handle inter-wave conflicts
                const uint laneIndex = WaveGetLaneIndex();
                const bool isLo = gridIndexOffsetEncoded != WaveReadLaneAt(gridIndexOffsetEncoded, max(1, laneIndex) - 1) || !laneIndex;

                uint interval, intervalMax;
                WaveGetMaxInterval(isLo, interval, intervalMax);
            #endif

            UNITY_UNROLL
            for (j = 0; j < 3; j++)
            {
                UNITY_UNROLL
                for (k = 0; k < 3; k++)
                {
                    UNITY_UNROLL
                    for (l = 0; l < 3; l++)
                    {
                        const float weight = weights[j].x * weights[k].y * weights[l].z;
                        const float3 gridToParticle = (gridToParticleOffset -float3(j, k, l)) * FLUID_GRID_SPACING;
                        float3 momentum = weight * mul(c, gridToParticle);

                        #if !DISABLE_WAVE_SCATTER
                            uint stride = 1;
                            while (stride < intervalMax)
                            {
                                const uint dstLane = laneIndex + stride;
                                const float3 tempMomentum = WaveReadLaneAt(momentum, dstLane);

                                if (stride < interval)
                                    momentum += tempMomentum;

                                stride *= 2;
                            }

                            if (!isLo)
                                continue;
                        #endif

                        const uint dstGridIndexEncoded = gridIndexOffsetEncoded + GetFluidBlockGridIndexLinearLevel0(uint3(j, k, l), FLUID_BLOCK_PADDING);
                        const int3 momentumEncoded = EncodeFluidGridMomentum(momentum);

                        int _;
                        InterlockedAdd(MomentumGridEncoded_GSM[dstGridIndexEncoded].x, momentumEncoded.x, _);
                        InterlockedAdd(MomentumGridEncoded_GSM[dstGridIndexEncoded].y, momentumEncoded.y, _);
                        InterlockedAdd(MomentumGridEncoded_GSM[dstGridIndexEncoded].z, momentumEncoded.z, _);
                    }
                }
            }
        }

        GroupMemoryBarrierWithGroupSync();

        // write momentum to current blocks
        const uint3 dstGridOffset = GetFluidBlockIndexSpatialLevel0(gid.x) * FLUID_BLOCK_SIZE_LEVEL0;
        for (i = gi; i < FLUID_BLOCK_GRID_COUNT_LEVEL0; i += PARTICLE_TO_GRID_KERNEL_SIZE)
        {
            const uint3 srcGridIndex = GetFluidBlockGridIndexSpatialLevel0(i);
            const uint loadGridIndex = GetFluidBlockGridIndexLinearLevel0(srcGridIndex, FLUID_BLOCK_PADDING);

            const uint3 dstGridIndex = dstGridOffset +srcGridIndex;

            const int3 gridValue = MomentumGridEncoded_GSM[loadGridIndex];

            int _;
            InterlockedAdd(FluidGridLevel0[dstGridIndex + FLUID_GRID_CHANNEL1_OFFSET], gridValue.x, _);
            InterlockedAdd(FluidGridLevel0[dstGridIndex + FLUID_GRID_CHANNEL2_OFFSET], gridValue.y, _);
            InterlockedAdd(FluidGridLevel0[dstGridIndex + FLUID_GRID_CHANNEL3_OFFSET], gridValue.z, _);
        }

        // write to adjacent blocks
        UNITY_UNROLL
        for (i = 1; i < 8; i++)
        {
            // query adjacent block
            const uint3 adjacentGridIndex = uint3(i & 1, (i >> 1) & 1, i >> 2);
            const uint3 adjacentGridPositionLevel1 = adjacentGridIndex + GridPositionLevel1_GSM;
            const uint3 adjacentGridOffsetLevel1 = adjacentGridPositionLevel1 % FLUID_BLOCK_SIZE_LEVEL1;

            const uint adjacentBlockIndexLevel1Encoded = AdjacentBlockIndexLevel1_GSM[i];

            // level 2 doesn't have "ghost cells"(term used in original spgrid paper)
            // thus, if no level 1 block is allocated, grid values are just discarded
            if (IsValidEncodedFluidBlockIndex(adjacentBlockIndexLevel1Encoded))
            {
                const uint3 subblockMin = adjacentGridIndex * FLUID_BLOCK_SIZE_LEVEL0;
                const uint3 subblockMax = min(
                    subblockMin + FLUID_BLOCK_SIZE_LEVEL0, FLUID_BLOCK_SIZE_LEVEL0_PADDED);
                const uint3 subblockSize = subblockMax - subblockMin;

                const uint3 srcGridIndex = GetGridIndexSpatial(gi, subblockSize.xy);
                if (all(srcGridIndex < subblockSize))
                {
                    const uint loadGridIndex = GetFluidBlockGridIndexLinearLevel0(subblockMin + srcGridIndex, FLUID_BLOCK_PADDING);

                    const int3 gridValue = MomentumGridEncoded_GSM[loadGridIndex];

                    const uint3 adjacentBlockIndexLevel1 = GetFluidBlockIndexSpatialLevel1(DecodeFluidBlockIndex(adjacentBlockIndexLevel1Encoded));
                    const uint3 adjacentGridIndexLevel1 = adjacentBlockIndexLevel1 * FLUID_BLOCK_SIZE_LEVEL1 + adjacentGridOffsetLevel1;
                    const uint3 adjacentBlockIndexLevel0Encoded = FluidGridLevel1[adjacentGridIndexLevel1];

                    if (IsValidEncodedFluidBlockIndex(adjacentBlockIndexLevel0Encoded))
                    {
                        const uint3 adjacentBlockIndexLevel0 = GetFluidBlockIndexSpatialLevel0(DecodeFluidBlockIndex(adjacentBlockIndexLevel0Encoded));
                        const uint3 dstGridIndex = adjacentBlockIndexLevel0 * FLUID_BLOCK_SIZE_LEVEL0 + srcGridIndex;

                        int _;
                        InterlockedAdd(FluidGridLevel0[dstGridIndex + FLUID_GRID_CHANNEL1_OFFSET], gridValue.x, _);
                        InterlockedAdd(FluidGridLevel0[dstGridIndex + FLUID_GRID_CHANNEL2_OFFSET], gridValue.y, _);
                        InterlockedAdd(FluidGridLevel0[dstGridIndex + FLUID_GRID_CHANNEL3_OFFSET], gridValue.z, _);
                    }
                    else
                    {
                        // if the level 0 is not allocated, add quantity to the coarser grid
                        #if !DISABLE_WAVE_SCATTER
                            const int3 gridValueSum = WaveActiveSum(gridValue);

                            if (!gi)
                            {
                                int _;
                                InterlockedAdd(FluidGridLevel1[adjacentGridIndexLevel1 + FLUID_GRID_CHANNEL1_OFFSET], gridValueSum.x, _);
                                InterlockedAdd(FluidGridLevel1[adjacentGridIndexLevel1 + FLUID_GRID_CHANNEL2_OFFSET], gridValueSum.y, _);
                                InterlockedAdd(FluidGridLevel1[adjacentGridIndexLevel1 + FLUID_GRID_CHANNEL3_OFFSET], gridValueSum.z, _);
                            }
                        #else
                            int _;
                            InterlockedAdd(FluidGridLevel1[adjacentGridIndexLevel1 + FLUID_GRID_CHANNEL1_OFFSET], gridValue.x, _);
                            InterlockedAdd(FluidGridLevel1[adjacentGridIndexLevel1 + FLUID_GRID_CHANNEL2_OFFSET], gridValue.y, _);
                            InterlockedAdd(FluidGridLevel1[adjacentGridIndexLevel1 + FLUID_GRID_CHANNEL3_OFFSET], gridValue.z, _);
                        #endif
                    }
                }
            }
        }
    }
}

/// end particle to grid

/// begin solve grid

#define SOLVE_GRID_LEVEL0_KERNEL_SIZE FLUID_BLOCK_SIZE_LEVEL0
#define SOLVE_GRID_LEVEL1_KERNEL_SIZE FLUID_BLOCK_SIZE_LEVEL1

SamplerState SamplerLinearClamp;
#define SCENE_VOLUME_SAMPLER SamplerLinearClamp

#include "../Graphics/SceneVolumeSampling.cginc"

void SolveGrid(float mass, float3 momentum, out float3 velocity)
{
    velocity = mass > 0.0 ? momentum / mass : 0.0;
    velocity += TIME_STEP * GLOBAL_GRAVITY;

    // todo
    // apply boundary condition here

}

[numthreads(SOLVE_GRID_LEVEL0_KERNEL_SIZE, SOLVE_GRID_LEVEL0_KERNEL_SIZE, SOLVE_GRID_LEVEL0_KERNEL_SIZE)]
void SolveGridLevel0(uint3 gid : SV_GroupID, uint3 gtid : SV_GroupThreadID)
{
    FOR_BLOCK_DISPATCH_LEVEL0(gid)
    {
        const uint3 blockIndex = GetFluidBlockIndexSpatialLevel0(gid.x);
        const uint3 gridIndex = blockIndex * FLUID_BLOCK_SIZE_LEVEL0 + gtid;

        const int massEncoded = FluidGridLevel0[gridIndex + FLUID_GRID_CHANNEL0_OFFSET];
        const int3 momentumEncoded = int3(
            FluidGridLevel0[gridIndex + FLUID_GRID_CHANNEL1_OFFSET],
            FluidGridLevel0[gridIndex + FLUID_GRID_CHANNEL2_OFFSET],
            FluidGridLevel0[gridIndex + FLUID_GRID_CHANNEL3_OFFSET]);

        const float mass = DecodeFluidGridMass(massEncoded);
        const float3 momentum = DecodeFluidGridMomentum(momentumEncoded);

        float3 velocity;
        SolveGrid(mass, momentum, velocity);

        #if !DISABLE_SDF_COLLISION
            const uint3 gridPosition = GetFluidBlockPosition(gid.x) * FLUID_BLOCK_SIZE_LEVEL0 + gtid;
            const float3 positionSDFSpace = gridPosition * FLUID_GRID_SPACING + FluidGridTranslation - SDFSceneTranslation;
            const float3 sdfSampleLocation = positionSDFSpace * SCENE_VOLUME_TEXEL;
            if (all(sdfSampleLocation > 0.0 && sdfSampleLocation < 1.0))
            {
                const float nsdf = SampleNormalizedSDF(sdfSampleLocation, 0.0);
                if (nsdf < 0.0)
                {
                    const float3 normal = SampleNormal(sdfSampleLocation, 0.0);
                    const float nv = dot(normal, velocity);
                    if (nv < 0.0)
                        velocity -= nv * normal;
                }
            }
        #endif

        const int3 velocityEncoded = EncodeFluidGridMomentum(velocity);
        FluidGridLevel0[gridIndex + FLUID_GRID_CHANNEL1_OFFSET] = velocityEncoded.x;
        FluidGridLevel0[gridIndex + FLUID_GRID_CHANNEL2_OFFSET] = velocityEncoded.y;
        FluidGridLevel0[gridIndex + FLUID_GRID_CHANNEL3_OFFSET] = velocityEncoded.z;
    }
}

[numthreads(SOLVE_GRID_LEVEL1_KERNEL_SIZE, SOLVE_GRID_LEVEL1_KERNEL_SIZE, SOLVE_GRID_LEVEL1_KERNEL_SIZE)]
void SolveGridLevel1(uint3 gid : SV_GroupID, uint3 gtid : SV_GroupThreadID)
{
    FOR_BLOCK_DISPATCH_LEVEL1(gid)
    {
        const uint3 blockIndex = GetFluidBlockIndexSpatialLevel1(gid.x);
        const uint3 gridIndex = blockIndex * FLUID_BLOCK_SIZE_LEVEL1 + gtid;

        const int massEncoded = FluidGridLevel1[gridIndex + FLUID_GRID_CHANNEL0_OFFSET];
        if (!IsValidEncodedFluidBlockIndex(massEncoded))
        {
            const int3 momentumEncoded = int3(
                FluidGridLevel1[gridIndex + FLUID_GRID_CHANNEL1_OFFSET],
                FluidGridLevel1[gridIndex + FLUID_GRID_CHANNEL2_OFFSET],
                FluidGridLevel1[gridIndex + FLUID_GRID_CHANNEL3_OFFSET]);

            const float mass = DecodeFluidGridMass(massEncoded);
            const float3 momentum = DecodeFluidGridMomentum(momentumEncoded);

            float3 velocity;
            SolveGrid(mass, momentum, velocity);

            const int3 velocityEncoded = EncodeFluidGridMomentum(velocity);
            FluidGridLevel1[gridIndex + FLUID_GRID_CHANNEL1_OFFSET] = velocityEncoded.x;
            FluidGridLevel1[gridIndex + FLUID_GRID_CHANNEL2_OFFSET] = velocityEncoded.y;
            FluidGridLevel1[gridIndex + FLUID_GRID_CHANNEL3_OFFSET] = velocityEncoded.z;
        }
    }
}

/// end solve grid

/// begin grid to particle

#define GRID_TO_PARTICLE_KERNEL_SIZE 128

groupshared float3 VelocityGrid_GSM[FLUID_BLOCK_GRID_COUNT_LEVEL0_PADDED];

[numthreads(GRID_TO_PARTICLE_KERNEL_SIZE, 1, 1)]
void GridToParticle(uint3 gid : SV_GroupID, uint gi : SV_GroupIndex)
{
    FOR_BLOCK_DISPATCH_LEVEL0(gid)
    {
        if (!gi)
        {
            GetFluidBlockInfo(gid.x, GridPositionLevel1_GSM, ParticleCount_GSM, ParticleOffset_GSM);
        }

        uint i, j, k, l;

        // read velocity from current block
        const uint3 srcGridOffset = GetFluidBlockIndexSpatialLevel0(gid.x) * FLUID_BLOCK_SIZE_LEVEL0;
        for (i = gi; i < FLUID_BLOCK_GRID_COUNT_LEVEL0; i += GRID_TO_PARTICLE_KERNEL_SIZE)
        {
            const uint3 dstGridIndex = GetFluidBlockGridIndexSpatialLevel0(i);
            const uint storeGridIndex = GetFluidBlockGridIndexLinearLevel0(dstGridIndex, FLUID_BLOCK_PADDING);
            const uint3 srcGridIndex = srcGridOffset +dstGridIndex;

            const int3 velocityEncoded = int3(
                FluidGridLevel0[srcGridIndex + FLUID_GRID_CHANNEL1_OFFSET],
                FluidGridLevel0[srcGridIndex + FLUID_GRID_CHANNEL2_OFFSET],
                FluidGridLevel0[srcGridIndex + FLUID_GRID_CHANNEL3_OFFSET]);

            VelocityGrid_GSM[storeGridIndex] = DecodeFluidGridMomentum(velocityEncoded);
        }

        // indices of adjacent blocks to load
        if (gi < 8)
        {
            const uint3 adjacentGridIndex = uint3(gi & 1, (gi >> 1) & 1, gi >> 2);
            const uint3 adjacentGridPositionLevel1 = adjacentGridIndex + GridPositionLevel1_GSM;
            const uint3 adjacentGridPositionLevel2 = adjacentGridPositionLevel1 / FLUID_BLOCK_SIZE_LEVEL1;
            AdjacentBlockIndexLevel1_GSM[gi] = FluidGridLevel2[adjacentGridPositionLevel2];
        }

        GroupMemoryBarrierWithGroupSync();

        // read velocity from adjacent blocks
        UNITY_UNROLL
        for (i = 1; i < 8; i++)
        {
            // query adjacent block
            const uint3 adjacentGridIndex = uint3(i & 1, (i >> 1) & 1, i >> 2);
            const uint3 adjacentGridPositionLevel1 = adjacentGridIndex + GridPositionLevel1_GSM;
            const uint3 adjacentGridOffsetLevel1 = adjacentGridPositionLevel1 % FLUID_BLOCK_SIZE_LEVEL1;

            const uint adjacentBlockIndexLevel1Encoded = AdjacentBlockIndexLevel1_GSM[i];

            const uint3 subblockMin = adjacentGridIndex * FLUID_BLOCK_SIZE_LEVEL0;
            const uint3 subblockMax = min(
                subblockMin + FLUID_BLOCK_SIZE_LEVEL0, FLUID_BLOCK_SIZE_LEVEL0_PADDED);
            const uint3 subblockSize = subblockMax - subblockMin;

            const uint3 dstGridIndex = GetGridIndexSpatial(gi, subblockSize.xy);
            const uint storeGridIndex = GetFluidBlockGridIndexLinearLevel0(subblockMin + dstGridIndex, FLUID_BLOCK_PADDING);

            if (all(dstGridIndex < subblockSize))
            {
                if (IsValidEncodedFluidBlockIndex(adjacentBlockIndexLevel1Encoded))
                {
                    const uint3 adjacentBlockIndexLevel1 = GetFluidBlockIndexSpatialLevel1(DecodeFluidBlockIndex(adjacentBlockIndexLevel1Encoded));
                    const uint3 adjacentGridIndexLevel1 = adjacentBlockIndexLevel1 * FLUID_BLOCK_SIZE_LEVEL1 + adjacentGridOffsetLevel1;
                    const uint3 adjacentBlockIndexLevel0Encoded = FluidGridLevel1[adjacentGridIndexLevel1];

                    int3 velocityEncoded;
                    if (IsValidEncodedFluidBlockIndex(adjacentBlockIndexLevel0Encoded))
                    {
                        const uint3 adjacentBlockIndexLevel0 = GetFluidBlockIndexSpatialLevel0(DecodeFluidBlockIndex(adjacentBlockIndexLevel0Encoded));
                        const uint3 srcGridIndex = adjacentBlockIndexLevel0 * FLUID_BLOCK_SIZE_LEVEL0 + dstGridIndex;

                        velocityEncoded = int3(
                            FluidGridLevel0[srcGridIndex + FLUID_GRID_CHANNEL1_OFFSET],
                            FluidGridLevel0[srcGridIndex + FLUID_GRID_CHANNEL2_OFFSET],
                            FluidGridLevel0[srcGridIndex + FLUID_GRID_CHANNEL3_OFFSET]);
                    }
                    else
                    {
                        // if the level 0 is not allocated, read from the coarser grid
                        velocityEncoded = int3(
                            FluidGridLevel1[adjacentGridIndexLevel1 + FLUID_GRID_CHANNEL1_OFFSET],
                            FluidGridLevel1[adjacentGridIndexLevel1 + FLUID_GRID_CHANNEL2_OFFSET],
                            FluidGridLevel1[adjacentGridIndexLevel1 + FLUID_GRID_CHANNEL3_OFFSET]);
                    }

                    VelocityGrid_GSM[storeGridIndex] = DecodeFluidGridMomentum(velocityEncoded);
                }
                else
                {
                    // otherwise extrapolate from current block
                    const uint indexClamped = clamp(storeGridIndex, 0, FLUID_BLOCK_SIZE_LEVEL0);
                    const uint index = GetFluidBlockGridIndexLinearLevel0(indexClamped, FLUID_BLOCK_PADDING);
                    VelocityGrid_GSM[storeGridIndex] = VelocityGrid_GSM[index];
                }
            }
        }

        GroupMemoryBarrierWithGroupSync();

        // take complementary since particles are sorted into another ping-pong buffer in p2g
        const bool pingpongFlag = GetFluidParticlePositionPingPongFlag();

        // per particle gather
        for (i = gi; i < ParticleCount_GSM; i += GRID_TO_PARTICLE_KERNEL_SIZE)
        {
            // particles have been sorted into a linear array in particle-to-grid transfer.
            // thus they can be indexed without per-particle indirection.
            const uint particleIndex = ParticleOffset_GSM + i;

            ParticlePositionIndexed position = GetFluidParticlePosition(particleIndex, pingpongFlag);

            const float3 gridSpacePosition = GetGridSpacePosition(position.Position);

            uint3 gridIndexOffset;
            float3 gridToParticleOffset;
            float3 weights[3];
            CalculateParticleGridTransfer(
                gridSpacePosition, GridPositionLevel1_GSM, gridIndexOffset, gridToParticleOffset,
                weights[0], weights[1], weights[2]);

            const uint gridIndexOffsetEncoded = GetFluidBlockGridIndexLinearLevel0(gridIndexOffset, FLUID_BLOCK_PADDING);

            float3x3 affine = 0.0;
            float3 velocity = 0.0;
            UNITY_UNROLL
            for (j = 0; j < 3; j++)
            {
                UNITY_UNROLL
                for (k = 0; k < 3; k++)
                {
                    UNITY_UNROLL
                    for (l = 0; l < 3; l++)
                    {
                        const float weight = weights[j].x * weights[k].y * weights[l].z;

                        const uint gridIndexEncoded = gridIndexOffsetEncoded + GetFluidBlockGridIndexLinearLevel0(uint3(j, k, l), FLUID_BLOCK_PADDING);
                        const float3 weightedVelocity = weight * VelocityGrid_GSM[gridIndexEncoded];

                        const float3 gridToParticle = (gridToParticleOffset -float3(j, k, l)) * FLUID_GRID_SPACING;
                        affine += float3x3(
                            gridToParticle * weightedVelocity.x,
                            gridToParticle * weightedVelocity.y,
                            gridToParticle * weightedVelocity.z);

                        velocity += weightedVelocity;
                    }
                }
            }

            position.Position += velocity * TIME_STEP;

            #if !DISABLE_SDF_COLLISION
                // move particle out of implicit surface
                const float3 positionSDFSpace = position.Position - SDFSceneTranslation;
                const float3 sdfSampleLocation = positionSDFSpace * SCENE_VOLUME_TEXEL;
                if (all(sdfSampleLocation > 0.0 && sdfSampleLocation < 1.0))
                {
                    const float nsdf = SampleNormalizedSDF(sdfSampleLocation, 0.0);
                    if (nsdf <= 0.0)
                    {
                        const float sdf = nsdf * 4.0;
                        const float3 normal = SampleNormal(sdfSampleLocation, 0.0);
                        const float3 displacement = -sdf * normal;
                        // position.Position += displacement;
                        velocity += displacement * TIME_STEP_INV;

                        // const float nv = dot(normal, velocity);
                        // if (nv < 0.0)
                        //     velocity -= nv * normal;

                    }
                }
            #endif

            SetFluidParticlePosition(particleIndex, position, pingpongFlag);
            SetFluidParticleAffineVelocity(position.Index, affine, velocity);
        }
    }
}

/// end grid to particle

/// begin add particle

#include "../Shaders/Random.cginc"

#define ADD_PARTICLES_KERNEL_SIZE 128
#define MAX_EMITTER_PARTICLE_COUNT_PER_GROUP (ADD_PARTICLES_KERNEL_SIZE * 8)

#define EMITTER_TYPE_PARTICLE 0
#define EMITTER_TYPE_CUBE 1

CBUFFER_START(AddParticlesParameters)
    float Mass;

    uint RandomSeed;
CBUFFER_END

struct FluidEmitterDispatch
{
    uint Type;

    // in bytes
    uint ParameterOffset;

    uint ParticleCountInclusiveSum;
};

extern StructuredBuffer<FluidEmitterDispatch> FluidEmitterDispatches;
extern Buffer<uint> FluidEmitterPartitions;

// layout: { <valid emitter paramter layout>* }
extern ByteAddressBuffer FluidEmitterProperties;

void GetEmittedParticle(
    uint emitterType, uint emitterParameterOffset, uint emitterParticleIndex,
    inout Random random, out float3 position, out float3 velocity, out float mass)
{
    switch(emitterType)
    {
        case EMITTER_TYPE_PARTICLE:
            {
                const uint offset = emitterParameterOffset +emitterParticleIndex * 24;
                const float4 word0 = asfloat(FluidEmitterProperties.Load4(offset));
                const float2 word1 = asfloat(FluidEmitterProperties.Load2(offset +16));

                position = word0.xyz;
                velocity = float3(word0.w, word1);
            }
            break;
        case EMITTER_TYPE_CUBE:
            {
                const uint offset = emitterParameterOffset;
                const float4 word0 = asfloat(FluidEmitterProperties.Load4(offset));
                const float4 word1 = asfloat(FluidEmitterProperties.Load4(offset +16));
                const float4 word2 = asfloat(FluidEmitterProperties.Load4(offset +32));

                const float3 cubeMin = float3(word0.xyz);
                const float3 cubeMax = float3(word0.w, word1.xy);
                const float3 linearVelocity = float3(word1.zw, word2.x);
                const float3 angularVelocity = float3(word2.yzw);

                const float3 uvw = random.Next01x3();
                position = lerp(cubeMin, cubeMax, uvw);

                const float3 cubeCenter = (cubeMax + cubeMin) * 0.5;
                velocity = cross(angularVelocity, position - cubeCenter);
                velocity += linearVelocity;
            }
            break;
        default:
            {
                // conspicuous value for debugging
                position = float(-42.0).xxx;
                velocity = float(-42.0).xxx;
            }
            break;
    }

    mass = Mass;
}

groupshared uint EmitterOffset_GSM;
groupshared uint EmitterCount_GSM;
groupshared uint EmitterParticleOffset_GSM;
groupshared uint EmitterTypes_GSM[MAX_EMITTER_PARTICLE_COUNT_PER_GROUP];
groupshared uint EmitterParameterOffsets_GSM[MAX_EMITTER_PARTICLE_COUNT_PER_GROUP];
groupshared uint EmitterIndices_GSM[MAX_EMITTER_PARTICLE_COUNT_PER_GROUP + 1];
groupshared uint TotalEmitterParticleCount_GSM;

[numthreads(ADD_PARTICLES_KERNEL_SIZE, 1, 1)]
void AddParticles(const uint3 tid : SV_DispatchThreadID, const uint3 gid : SV_GroupID, const uint gi : SV_GroupIndex)
{
    uint i, j;

    // clear emitter indices
    for (i = gi; i < MAX_EMITTER_PARTICLE_COUNT_PER_GROUP; i += ADD_PARTICLES_KERNEL_SIZE)
    {
        EmitterIndices_GSM[i] = ~0u;
    }

    if (!gi)
    {
        EmitterIndices_GSM[0] = 0;
        EmitterOffset_GSM = FluidEmitterPartitions[gid.x];
        EmitterCount_GSM = FluidEmitterPartitions[gid.x + 1] - EmitterOffset_GSM;
        EmitterParticleOffset_GSM = gid.x * MAX_EMITTER_PARTICLE_COUNT_PER_GROUP;
    }

    GroupMemoryBarrierWithGroupSync();

    // load emitters to gsm
    FluidEmitterDispatch dispatch;
    for (i = gi; i < EmitterCount_GSM; i += ADD_PARTICLES_KERNEL_SIZE)
    {
        dispatch = FluidEmitterDispatches[i + EmitterOffset_GSM];
        EmitterTypes_GSM[i] = dispatch.Type;
        EmitterParameterOffsets_GSM[i] = dispatch.ParameterOffset;
        EmitterIndices_GSM[dispatch.ParticleCountInclusiveSum] = i + 1;
    }

    const uint prevParticleCount = GetFluidParticleCount();
    if (i == EmitterCount_GSM + ADD_PARTICLES_KERNEL_SIZE - 1)
    {
        const uint particleHi = prevParticleCount + EmitterParticleOffset_GSM + MAX_EMITTER_PARTICLE_COUNT_PER_GROUP;
        TotalEmitterParticleCount_GSM = min(dispatch.ParticleCountInclusiveSum, FLUID_MAX_PARTICLE_COUNT - particleHi);
    }

    GroupMemoryBarrierWithGroupSync();

    // broadcast emitters
    for (i = 1; i < TotalEmitterParticleCount_GSM; i *= 2)
    {
        for (j = gi; j < TotalEmitterParticleCount_GSM - i; j += ADD_PARTICLES_KERNEL_SIZE)
        {
            const uint current = EmitterIndices_GSM[j];
            if (current != ~0)
            {
                const uint nextIndex = j + i;
                const uint next = EmitterIndices_GSM[nextIndex];
                if (next == ~0)
                    EmitterIndices_GSM[nextIndex] = current;
            }
        }

        GroupMemoryBarrierWithGroupSync();
    }

    const bool pingpongFlag = GetFluidParticlePositionPingPongFlag();
    const uint poolSize = GetPooledParticlePropertyCount();

    Random random;
    random.Seed(RandomSeed, tid.x);

    for (i = gi; i < TotalEmitterParticleCount_GSM; i += ADD_PARTICLES_KERNEL_SIZE)
    {
        const uint emitterIndex = EmitterIndices_GSM[i];
        const uint emitterType = EmitterTypes_GSM[emitterIndex];
        const uint emitterParameterOffset = EmitterParameterOffsets_GSM[emitterIndex];

        float3 position;
        float3 velocity;
        float mass;
        // todo
        // err to use particle index i
        GetEmittedParticle(emitterType, emitterParameterOffset, i, random, position, velocity, mass);

        const uint particleIndex = EmitterParticleOffset_GSM + i;

        uint propertyIndex;
        if (particleIndex < poolSize)
            propertyIndex = GetPooledParticleProperty(poolSize - 1 - particleIndex);
        else
            propertyIndex = prevParticleCount + particleIndex;

        ParticlePositionIndexed positionIndexed;
        positionIndexed.Position = position;
        positionIndexed.Index = propertyIndex;

        ParticleProperty property;
        property.SetVelocity(velocity);
        property.SetZeroAffine();
        property.Mass = mass;

        SetFluidParticlePosition(prevParticleCount + particleIndex, positionIndexed, pingpongFlag);
        SetFluidParticleProperty(propertyIndex, property);
    }
}

/// end add particle
